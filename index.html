<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.1.2/howler.core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.48.4/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.1.0/chroma.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.48.4/codemirror.min.css" />
<style>
* {
    margin: 0;
    padding: 0;
}
html, body {
    margin: 0;
    width: 100%;
    height: 100%;
    border: 0;
    overflow: hidden;
    display: block;
}
body {
    display: flex;
}
body.horizontal {
    flex-direction: column;
}
body.vertical {
    flex-direction: row;
}
#editor {
    flex-grow: 1;
}
#canvas {
}
.CodeMirror {
    font-size: 20px;
    border: 1px solid #eee;
    height: auto;
}
.horizontal footer {
    min-height: 48px;
}
.vertical footer {
    display: none;
}


.cm-s-default .cm-keyword     { color: blue; }
.cm-s-default .cm-punctuation { color: red;  }
.cm-s-default .cm-comment     { color: #488; }
.cm-s-default .cm-parameter   { color: #a1a; }

</style>
</head>
<body>
<canvas id=canvas>
</canvas>
<div id=editor>
</div>
<footer>
</footer>

<script>

"use strict";

var background_color = "white"

class Dot {
    constructor(pulse, symbol) {
        this.pulse = pulse
        this.symbol = symbol
        this.played_pulse = null
    }
    get active() {
        return this.symbol != '.'
    }
}

class Ring {
    constructor(name, instrument, pattern, opts) {
        this.name = name
        this.instrument = instrument
        this.pattern = pattern
        opts = Object.assign({ volume: 1.0 }, opts);
        this.volume = opts.volume
        this.dots = []
        let pulse = 0
        for (const symbol of pattern) {
            if (/\s/.test(symbol)) continue
            
            this.dots.push(new Dot(pulse, symbol))
            pulse++
        }
        this.period = this.dots.length
    }
}

class Sound extends Howl {
    constructor(src, volume_factor) {
        super({ src })
        this.volume_factor = volume_factor === undefined ? 1.0 : volume_factor
        this.volume_factor *= 0.5
    }
    play(volume) {
        super.volume(volume * this.volume_factor)
        super.play()
    }
}

class Instrument {
    constructor(sound) {
        this.sound = sound
    }
    play(symbol, volume) {
        let sound = this.sound instanceof Sound ? this.sound : this.sound[symbol]
        sound.play(volume)
    }
}

var palette = [
"#1f77b4",
"#ff7f0e",
"#2ca02c",
"#d62728",
"#9467bd",
"#8c564b",
"#17becf",
"#e377c2",
"#b4b518",
]

var pulse_width = 150

function update_pulse_width(width) {
    let lines = editor.getValue().split(/\r?\n/)
    if (/^#!/.test(lines[0])) {
        lines[0] = lines[0].replace(/\bp\d+\b/, "p"+width)
    } else {
        lines.unshift("#! p" + width)
    }
    editor.setValue(lines.join("\n"))
}

var sounds = {
    'beat':             new Sound('beat-wood.mp3', 0.4),
    'beat_high':        new Sound('beat-wood-high.mp3', 0.15),
    'clap':             new Sound('clap.mp3'),
    'shake':            new Sound('shake.mp3', 0.2),
    'dundunba':         new Sound('dundunba.mp3', 0.25),
    'sangban':          new Sound('sangban.mp3', 0.2),
    'sangban_closed':   new Sound('sangban-closed.mp3', 0.2),
    'kenkeni':          new Sound('kenkeni.mp3', 0.2),
    'djembe_slap':      new Sound('djembe-slap.mp3'),
    'djembe_tone':      new Sound('djembe-tone.mp3'),
}


var instruments = {
    'clave':       new Instrument({ x: sounds.beat, h: sounds.beat_high }),
    'shekere':     new Instrument(sounds.shake),
    'sangban':     new Instrument({ x: sounds.sangban, c: sounds.sangban_closed }),
    'dundunba':    new Instrument(sounds.dundunba),
    'kenkeni':     new Instrument(sounds.kenkeni),
    'djembe':      new Instrument({ s: sounds.djembe_slap, t: sounds.djembe_tone })
}

function parse_rhythm (text) {
    let rings = []
    let name = ""
    let pattern = ""
    let opts = {}

    function valid(name, pattern) {
        return (name in instruments) && !/^\s*$/.test(pattern)
    }

    let first = true
    for (let line of text.split(/\r?\n/)) {
        if (first && /^#!/.test(line)) {
            const tokens = line.substring(2).split(/\s+/)
            for (let token of tokens) {
                const res = token.match(/^p(\d+)$/)
                if (res) {
                    pulse_width = parseInt(res[1])
                }
            }
        }
        first = false
        line = line.replace(/#.*/, "")
        const res = line.match(/([^:\s][^:]*):(.*)/)
        if (res) {
            if (valid(name, pattern)) {
                rings.push(new Ring(name, instruments[name], pattern, opts))
            }
            const tokens = res[1].split(/\s+/)
            name = tokens[0]
            pattern = res[2]
            opts = {}
            for (let token of tokens) {
                const res = token.match(/v(\d*\.?\d+)/)
                if (res) {
                    opts.volume = parseFloat(res[1])
                }
            }
        } else {
            pattern += (pattern ? "\n" : "") + line
        }
    }
    if (valid(name, pattern)) {
        rings.push(new Ring(name, instruments[name], pattern, opts))
    }
    return rings
}


const text = window.localStorage.getItem("text") || `\
shekere:  x... x... x... x...
sangban:  c... x...
dundunba: x... .... x.x. ....
#djembe:   s..s s.tt
djembe:  #tts. ts.. s..t .st.
         #.s.. t.ss ..t. ..ss
         #tts. .stt s..s ..s.
         #.tss t.tt ..st ttss
          ttst tstt stts ttst
          tstt s.ss ttst tss.
`

var rings = parse_rhythm(text)

CodeMirror.defineMode("rhythm", function() {
    return {
        token: function(stream) {
            if (stream.eatSpace()) {
                return null
            }
            if (stream.match("#")) {
                stream.skipToEnd();
                return "comment";
            }
            for (const word of ["djembe", "dundunba", "dununba", "sangban", "kenkeni", "shekere", "clave"]) {
                if (stream.match(word, true, true)) {
                    return "keyword"
                }
            }
            if (stream.match(":")) {
                return "punctuation"
            }
            if (stream.match(/v\d*\.?\d+/)) {
                return "parameter"
            }
            stream.eatWhile(/\S/)
            return null;
        }
    }
})

var editor = CodeMirror(document.getElementById("editor"), { mode: "rhythm", value: text })


function in_limits(x, l1, l2) {
    return x >= l1 && x < l2
}

function update(elapsed) {
    for (let ring of rings) {
        const pulse = elapsed / pulse_width
        
        //console.log(`process elapsed=${elapsed} ring_name=${ring.name} pulse=${pulse}`)
        
        for (let dot of ring.dots) {
            if (ring.volume > 0 && dot.active
                && in_limits((pulse - dot.pulse) % ring.period, -0.02, 1.0)
                && (dot.played_pulse ==  null || pulse - dot.played_pulse > ring.period - 0.1)) {
                
                ring.instrument.play(dot.symbol, ring.volume)
                dot.played_pulse = pulse
                
                //console.log(`playing pulse=${pulse} ring_name=${ring.name} dot=${dot.pulse}`)
            }
        }
    }
}

function process(ts) {
    if (start_ts) {
        update(ts - start_ts)
    }
    draw(ts - start_ts)
    window.requestAnimationFrame(process)
}

function stop() {
    console.log(`stopping ts=${start_ts}`)
    start_ts = 0;
    for (let ring of rings) {
        for (let dot of ring.dots) {
            dot.played_pulse = null
        }
    }
}

function start() {
    start_ts = performance.now() + 50.0
    console.log(`starting ts=${start_ts}`)
}

function on_click() {
    toggle_play()
}

function toggle_play() {
    if (start_ts) {
        stop()
    } else {
        start()
    }
}

function draw(elapsed) {

    const canvas = document.getElementById('canvas')
    const ctx = canvas.getContext('2d')
    ctx.clearRect(0, 0, canvas.width, canvas.height)
    if (!rings.length) {
        return
    }

    const pulse = elapsed / pulse_width
    var period = rings[0].period
    var radii_count = rings.reduce((count, ring) => count + Math.ceil(ring.period / period), 0)

    let width = Math.min(canvas.width, canvas.height)
    let radius = width * 0.15
    let radius_delta = width * 0.3 / Math.max(3, radii_count - 1)
    for (const [ring_id, ring] of rings.entries()) {
        const part_count = Math.ceil(ring.period / period)
        for (let part = 0; part < part_count; part++) {
            for (let iteration = 0; iteration < Math.ceil(period / ring.period); iteration++) {
                for (let dot of ring.dots) {
                    let iteration_dot_pulse = dot.pulse + iteration * ring.period
                    if (!in_limits(iteration_dot_pulse - part * period, 0, period)) {
                        continue
                    }

                    let angle = 2 * Math.PI * iteration_dot_pulse / period

                    let dot_x = canvas.width / 2 + Math.sin(angle) * radius
                    let dot_y = canvas.height / 2 - Math.cos(angle) * radius
                    let dot_size = width * 0.012
                    let playing = dot.active && start_ts && in_limits((pulse - iteration_dot_pulse) % (part_count * period), -0.1, 0.9)
                    
                    let angle_delta = 2.0 * Math.PI / period
                    let angle0 = - 0.5 * Math.PI + angle - angle_delta / 2
                    let angle1 = - 0.5 * Math.PI + angle + angle_delta / 2

                    let color = palette[ring_id % palette.length]

                    ctx.beginPath()
                    ctx.arc(canvas.width / 2, canvas.height / 2, radius + 0.45 * radius_delta, angle1, angle0, true)
                    ctx.arc(canvas.width / 2, canvas.height / 2, radius - 0.45 * radius_delta, angle0, angle1, false)
                    ctx.closePath()
                    if (ring.volume > 0) {
                        ctx.fillStyle = playing ? chroma(color).darken().saturate() : chroma.mix("#eee", color, ring.volume/2*0.6 + 0.2)
                    } else {
                        ctx.fillStyle = "#ddd"
                    }
                    ctx.fill()

                    if (dot.active) {
                        ctx.beginPath()
                        if (dot.symbol == 's' || dot.symbol == 'h') {
                            ctx.moveTo(dot_x,            dot_y - dot_size)
                            ctx.lineTo(dot_x - dot_size, dot_y + dot_size)
                            ctx.lineTo(dot_x + dot_size, dot_y + dot_size)
                        } else if (dot.symbol == 'c') {
                            ctx.moveTo(dot_x - dot_size, dot_y - dot_size)
                            ctx.lineTo(dot_x - dot_size, dot_y + dot_size)
                            ctx.lineTo(dot_x + dot_size, dot_y + dot_size)
                            ctx.lineTo(dot_x + dot_size, dot_y - dot_size)
                        } else {
                            ctx.arc(dot_x, dot_y, dot_size, 0, 2 * Math.PI)
                        }
                        ctx.closePath()
                        ctx.lineWidth = width * 0.012
                        ctx.strokeStyle = background_color
                        ctx.stroke()
                        ctx.fillStyle = ring.volume > 0 ? "#444" : "#888"
                        ctx.fill()
                    }
                }
            }
            
            radius += radius_delta
        }
    }
    
    for (let i = 0; i < period; i++) {
        let angle = 2 * Math.PI * (i + 0.5) / period
        ctx.beginPath()
        ctx.moveTo(canvas.width / 2, canvas.height / 2)
        ctx.lineTo(canvas.width / 2 + Math.sin(angle) * radius, canvas.height / 2 - Math.cos(angle) * radius)
        ctx.strokeStyle = background_color
        ctx.lineWidth = width * 0.006
        ctx.stroke()
    }


    const touch_ids = Object.keys(tracks)
    if (touch_ids.length == 1) {
        const track = tracks[touch_ids[0]]

        ctx.beginPath()
        let prev_point = null
        for (const point of track.points) {
            if (!prev_point) {
                ctx.moveTo(point.x, point.y)
            } else {
                ctx.lineTo(point.x, point.y)
            }
            prev_point = point
        }
        ctx.strokeStyle = "black"
        ctx.lineWidth = width * 0.030
        ctx.stroke()

        if ("drag" in track) {
            ctx.beginPath()
            ctx.moveTo(track.start.x, track.start.y)
            if (track.drag == "x") {
                ctx.lineTo(track.end.x, track.start.y)
            } else {
                ctx.lineTo(track.start.x, track.end.y)
            }
            ctx.strokeStyle = "blue"
            ctx.lineWidth = width * 0.030
            ctx.stroke()

            if (track.drag == "x") {
            } else {
                ctx.font = 'bold 64px sans-serif'
                ctx.fillStyle = "blue"
                ctx.strokeStyle = background_color
                ctx.strokeWidth = 2
                let str = "p" + Math.floor(pulse_width - (track.end.y - track.start.y) * 0.2 )
                ctx.strokeText(str, 50, 150)
                ctx.fillText(str, 50, 150)
            }
        }
    }
}

function resize() {
    const canvas = document.getElementById('canvas')
    let size = Math.min(window.innerWidth, window.innerHeight)
    document.body.className = window.innerWidth > window.innerHeight ? "vertical" : "horizontal"
    canvas.width = size
    canvas.height = size
    canvas_rect = canvas.getBoundingClientRect()
    reset_tracks()
}

function on_editor_change(editor) {
    const text = editor.getValue()
    rings = parse_rhythm(text)
    window.localStorage.setItem("text", text)
}


class Track {
    constructor(start_x, start_y) {
        this.points = [{ x: start_x, y: start_y }]
    }
    get start() {
        return this.points[0]
    }
    get end() {
        return this.points[this.points.length - 1]
    }
    add_point(x, y) {
        this.points.push({ x: x, y: y })
        if (!("drag" in this)) {
            if (Math.abs(y - this.start.y) > 20) {
                this.drag = "y"
            } else if (Math.abs(x - this.start.x) > 20) {
                this.drag = "x"
            }
        }
    }
}

var canvas_rect = null
var tracks

function on_mousedown(e) {
    e.preventDefault()
    start_track("m", e.clientX, e.clientY)
}

function on_mousemove(e) {
    e.preventDefault()
    update_track("m", e.clientX, e.clientY)
}

function on_mouseup(e) {
    e.preventDefault()
    end_tracks()
}


function start_track(id, x, y) {
    tracks[id] = new Track(x - canvas_rect.left, y - canvas_rect.top)
}

function update_track(id, x, y) {
    if (id in tracks) {
        tracks[id].add_point(x, y)
    }
}

function reset_tracks() {
    tracks = {}
}

function end_tracks() {
    let touch_ids = Object.keys(tracks)
    if (touch_ids.length == 1) {
        let track = tracks[touch_ids[0]]
        if ("drag" in track) {
            update_pulse_width(Math.floor(pulse_width - (track.end.y - track.start.y) * 0.2 ))
        } else {
            toggle_play()
        }
    }
    reset_tracks()
}

function on_touchstart(e) {
    e.preventDefault()
    for (let t of e.changedTouches) {
        start_track(t.identifier, t.clientX, t.clientY)
    }
    if (Object.keys(tracks).length > 1) {
        reset_tracks()
    }
}

function on_touchmove(e) {
    e.preventDefault()
    for (let t of e.changedTouches) {
        update_track(t.identifier, t.clientX - canvas_rect.left, t.clientY - canvas_rect.top)
    }
}

function on_touchend(e) {
    e.preventDefault()
    end_tracks()
}

function on_touchcancel(e) {
    if(e.cancelable) {
        e.preventDefault()
    }
    reset_tracks()
}

window.requestAnimationFrame(process)
window.addEventListener('resize', resize, false)
document.getElementById('canvas').addEventListener("mousedown", on_mousedown)
document.getElementById('canvas').addEventListener("mousemove", on_mousemove)
document.getElementById('canvas').addEventListener("mouseup", on_mouseup)
document.getElementById('canvas').addEventListener("touchstart",  on_touchstart)
document.getElementById('canvas').addEventListener("touchmove",   on_touchmove)
document.getElementById('canvas').addEventListener("touchend",    on_touchend)
document.getElementById('canvas').addEventListener("touchcancel", on_touchcancel)
document.addEventListener('DOMContentLoaded', resize)
editor.on("focus", stop)
editor.on("changes", on_editor_change)

var start_ts = 0


</script>
</body>
</html>
