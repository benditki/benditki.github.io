<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.1.2/howler.core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.48.4/codemirror.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.48.4/codemirror.min.css" />
<style>
* {
    margin: 0;
    padding: 0;
}
html, body {
    margin: 0;
    width: 100%;
    height: 100%;
    border: 0;
    overflow: hidden;
    display: block;
}
body {
    display: flex;
}
body.horizontal {
    flex-direction: column;
}
body.vertical {
    flex-direction: row;
}
#editor {
    flex-grow: 1;
}
#canvas {
}
.CodeMirror {
    font-size: 20px;
    border: 1px solid #eee;
    height: auto;
}
.horizontal footer {
    min-height: 48px;
}
.vertical footer {
    display: none;
}


.cm-s-default .cm-keyword     { color: blue; }
.cm-s-default .cm-punctuation { color: red;  }
.cm-s-default .cm-comment     { color: #488; }
</style>
</head>
<body>
<canvas id=canvas>
</canvas>
<div id=editor>
</div>
<footer>
</footer>

<script>

class Dot {
    constructor(pulse, symbol) {
        this.pulse = pulse
        this.symbol = symbol
        this.played_pulse = null
    }
    get active() {
        return this.symbol != '.'
    }
}

class Ring {
    constructor(name, sound, pattern) {
        this.name = name
        this.sound = sound
        this.pattern = pattern
        this.dots = []
        let pulse = 0
        for (const symbol of pattern) {
            if (/\s/.test(symbol)) continue
            
            this.dots.push(new Dot(pulse, symbol))
            pulse++
        }
        this.period = this.dots.length
    }
}

var pulse_width = 120

var sounds = {
    'beat':             new Howl({ src: 'beat-wood.mp3' }),
    'beat_high':        new Howl({ src: 'beat-wood-high.mp3' }),
    'clap':             new Howl({ src: 'clap.mp3' }),
    'shake':            new Howl({ src: 'shake.mp3',    volume: 0.5 }),
    'dundunba':         new Howl({ src: 'dundunba.mp3', volume: 0.3 }),
    'sangban':          new Howl({ src: 'sangban.mp3',  volume: 0.2 }),
    'sangban_closed':   new Howl({ src: 'sangban-closed.mp3',  volume: 0.2 }),
    'kenkeni':          new Howl({ src: 'kenkeni.mp3',  volume: 0.2 }),
    'djembe_slap':      new Howl({ src: 'djembe-slap.mp3' }),
    'djembe_tone':      new Howl({ src: 'djembe-tone.mp3' }),
}


var instruments = {
    'shekere':     sounds.shake,
    'sangban':     { x: sounds.sangban, c: sounds.sangban_closed },
    'dundunba':    sounds.dundunba,
    'kenkeni':     sounds.kenkeni,
    'djembe':      { s: sounds.djembe_slap, t: sounds.djembe_tone }
}

function parse_rhythm (text) {
    let rings = []
    let name = ""
    let pattern = ""

    function valid(name, pattern) {
        return (name in instruments) && !/^\s*$/.test(pattern)
    }

    for (let line of text.split(/\r?\n/)) {
        line = line.replace(/#.*/, "")
        const res = line.match(/\s*([^\s:]+)\s*:(.*)/)
        if (res) {
            if (valid(name, pattern)) {
                rings.push(new Ring(name, instruments[name], pattern))
            }
            name = res[1]
            pattern = res[2]
        } else {
            pattern += (pattern ? "\n" : "") + line
        }
    }
    if (valid(name, pattern)) {
        rings.push(new Ring(name, instruments[name], pattern))
    }
    return rings
}

const text = `\
shekere:  x... x... x... x...
sangban:  c... x...
dundunba: x... .... x.x. ....
#djembe:   s..s s.tt
djembe:  #tts. ts.. s..t .st.
         #.s.. t.ss ..t. ..ss
         #tts. .stt s..s ..s.
         #.tss t.tt ..st ttss
          ttst tstt stts ttst
          tstt s.ss ttst tss.
`

var rings = parse_rhythm(text)

CodeMirror.defineMode("rhythm", function() {
    return {
        token: function(stream) {
            if (stream.eatSpace()) {
                return null
            }
            if (stream.match("#")) {
                stream.skipToEnd();
                return "comment";
            }
            for (word of ["djembe", "dundunba", "dununba", "sangban", "kenkeni", "shekere", "clave"]) {
                if (stream.match(word, true, true)) {
                    return "keyword"
                }
            }
            if (stream.match(":")) {
                return "punctuation"
            }
            stream.eatWhile(/\S/)
            return null;
        }
    }
})

var editor = CodeMirror(document.getElementById("editor"), { mode: "rhythm", value: text })


function in_limits(x, l1, l2) {
    return x >= l1 && x < l2
}

function update(elapsed) {
    for (let ring of rings) {
        const pulse = elapsed / pulse_width
        
        //console.log(`process elapsed=${elapsed} ring_name=${ring.name} pulse=${pulse}`)
        
        for (let dot of ring.dots) {
            if (dot.active
                && in_limits((pulse - dot.pulse) % ring.period, -0.02, 1.0)
                && (dot.played_pulse ==  null || pulse - dot.played_pulse > ring.period - 0.1)) {
                
                if (ring.sound instanceof Howl) {
                    ring.sound.play()
                } else {
                    ring.sound[dot.symbol].play()
                }
                dot.played_pulse = pulse
                
                //console.log(`playing pulse=${pulse} ring_name=${ring.name} dot=${dot.pulse}`)
            }
        }
    }
}

function process(ts) {
    if (start_ts) {
        update(ts - start_ts)
    }
    draw(ts - start_ts)
    window.requestAnimationFrame(process)
}

function stop() {
    console.log(`stopping ts=${start_ts}`)
    start_ts = 0;
    for (let ring of rings) {
        for (let dot of ring.dots) {
            dot.played_pulse = null
        }
    }
}

function start() {
    start_ts = performance.now() + 50.0
    console.log(`starting ts=${start_ts}`)
}

function on_click() {
    if (start_ts) {
        stop()
    } else {
        start()
    }
}

function draw(elapsed) {
    const pulse = elapsed / pulse_width
    
    const canvas = document.getElementById('canvas')
    const ctx = canvas.getContext('2d')
    ctx.clearRect(0, 0, canvas.width, canvas.height)
    
    if (!rings.length) {
        return
    }

    var period = rings[0].period
    var radii_count = rings.reduce((count, ring) => count + Math.ceil(ring.period / period), 0)

    let width = Math.min(canvas.width, canvas.height)
    let radius = width * 0.15
    for (let ring of rings) {
        const part_count = Math.ceil(ring.period / period)
        for (let part = 0; part < part_count; part++) {
            ctx.beginPath()
            ctx.arc(canvas.width / 2, canvas.height / 2, radius, 0, 2 * Math.PI)
            ctx.strokeStyle = 'black'
            ctx.lineWidth = width * 0.001
            ctx.stroke()
            for (let iteration = 0; iteration < Math.ceil(period / ring.period); iteration++) {
                for (let dot of ring.dots) {
                    let iteration_dot_pulse = dot.pulse + iteration * ring.period
                    if (!in_limits(iteration_dot_pulse - part * period, 0, period)) {
                        continue
                    }

                    let angle = 2 * Math.PI * iteration_dot_pulse / period
                    let dot_x = canvas.width / 2 + Math.sin(angle) * radius
                    let dot_y = canvas.height / 2 - Math.cos(angle) * radius
                    let dot_size = width * 0.015
                    let playing = start_ts && in_limits((pulse - iteration_dot_pulse) % (part_count * period), -0.1, 0.9)
                    
                    ctx.beginPath()
                    if (dot.symbol == 's') {
                        ctx.moveTo(dot_x,            dot_y - dot_size)
                        ctx.lineTo(dot_x - dot_size, dot_y + dot_size)
                        ctx.lineTo(dot_x + dot_size, dot_y + dot_size)
                        ctx.closePath()
                    } else if (dot.symbol == 'c') {
                        ctx.moveTo(dot_x - dot_size, dot_y - dot_size)
                        ctx.lineTo(dot_x - dot_size, dot_y + dot_size)
                        ctx.lineTo(dot_x + dot_size, dot_y + dot_size)
                        ctx.lineTo(dot_x + dot_size, dot_y - dot_size)
                        ctx.closePath()
                    } else {
                        ctx.arc(dot_x, dot_y, dot_size, 0, 2 * Math.PI)
                    }
                    ctx.lineWidth = width * 0.004
                    ctx.strokeStyle = playing ? 'blue' : 'black'
                    ctx.fillStyle =   dot.active ? (playing ? 'blue' : 'black') : 'white'
                    ctx.fill()
                    ctx.stroke()
                }
            }
            
            radius += width * 0.3 / Math.max(3, radii_count - 1)
        }
    }
}

function resize() {
    const canvas = document.getElementById('canvas')
    let size = Math.min(window.innerWidth, window.innerHeight)
    document.body.className = window.innerWidth > window.innerHeight ? "vertical" : "horizontal"
    canvas.width = size
    canvas.height = size
}

function on_editor_change(editor) {
    rings = parse_rhythm(editor.getValue())
}

window.requestAnimationFrame(process)
window.addEventListener('resize', resize, false)
document.getElementById('canvas').addEventListener("click", on_click)
document.addEventListener('DOMContentLoaded', resize)
editor.on("focus", stop)
editor.on("changes", on_editor_change)

var start_ts = 0

   
</script>
</body>
</html>
