<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.1.2/howler.core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.48.4/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.48.4/addon/scroll/simplescrollbars.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.1.0/chroma.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.48.4/codemirror.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.48.4/addon/scroll/simplescrollbars.min.css" />
<style>
* {
    margin: 0;
    padding: 0;
}
html, body {
    margin: 0;
    width: 100%;
    height: 100%;
    border: 0;
    overflow: hidden;
    display: block;
}
body {
    display: flex;
    align-items: center;
}
body.horizontal {
    flex-direction: column;
}
body.vertical {
    flex-direction: row;
}
#editor {
    flex-grow: 1;
    align-self: stretch;
}
#canvas {
}
.CodeMirror {
    font-size: 20px;
}

.CodeMirror {
    min-height: 100%;
    max-height: 100%;
    min-width: 100%;
    max-width: 100%;
}

.cm-s-default .cm-keyword     { color: blue; }
.cm-s-default .cm-punctuation { color: red;  }
.cm-s-default .cm-comment     { color: #488; }
.cm-s-default .cm-parameter   { color: #a1a; }

</style>
</head>
<body>
<canvas id=canvas>
</canvas>
<div id=editor>
</div>

<script>

"use strict";

var canvas = document.getElementById("canvas")

var background_color = "white"

class Dot {
    constructor(pulse, symbol) {
        this.pulse = pulse
        this.symbol = symbol
        this.played_pulse = null
    }
    get active() {
        return this.symbol.value != '.'
    }

    update_symbol(symbol) {
        editor.setValue(this.symbol.calc_text(symbol))
    }
}

class Ring {
    constructor(name, instrument, symbols, opts) {
        this.name = name
        this.instrument = instrument
        opts = Object.assign({ volume: { value: 1.0 } }, opts);
        this.volume = opts.volume
        this.dots = []
        let pulse = 0
        for (const symbol of symbols) {
            this.dots.push(new Dot(pulse, symbol))
            pulse++
        }
        this.period = this.dots.length
    }

    update_volume(volume) {
        if ("text" in this.volume) {
            editor.setValue(this.volume.calc_text(volume))
        } else {
            editor.setValue(Parsed.insert(this.name.text, this.name.pos + this.name.length, " v" + volume))
        }
    }

    update_name(name) {
        editor.setValue(this.name.calc_text(name))
    }
}

class Sound extends Howl {
    constructor(src, volume_factor) {
        super({ src })
        this.volume_factor = volume_factor === undefined ? 1.0 : volume_factor
        this.volume_factor *= 0.5
    }
    play(volume) {
        super.volume(volume * this.volume_factor)
        super.play()
    }
}

class Instrument {
    constructor(sound) {
        this.sound = sound
        if (this.sound instanceof Sound) {
            this.symbols = ["x"]
        } else {
            this.symbols = Object.keys(this.sound)
        }
    }

    play(symbol, volume) {
        let sound = this.sound instanceof Sound ? this.sound : this.sound[symbol]
        sound.play(volume)
    }

    next_symbol(symbol) {
        const symbol_id = this.symbols.indexOf(symbol)
        return symbol_id == this.symbols.length - 1 ? "." : this.symbols[symbol_id + 1]
    }
}

class Parsed {
    constructor(text, pos, length, value) {
        this.text = text
        this.pos = pos
        this.length = length
        this.value = value
    }

    calc_text(new_value) {
        return this.text.slice(0, this.pos) + new_value + this.text.slice(this.pos + this.length)
    }

    static insert(text, pos, what) {
        return text.slice(0, pos) + what + text.slice(pos)
    }
}

class Circle {
    constructor(name, rings, opts) {
        this.name = name
        this.rings = rings
        opts = Object.assign({ freq: { value: 7.0 }, repeats: { value: 0 } }, opts);
        this.freq = opts.freq
        this.repeats = opts.repeats
        
        this.dots = []
        let radius_id = 0
        for (const [ring_id, ring] of this.rings.entries()) {
            const part_count = Math.ceil(ring.period / this.period)
            for (let part = 0; part < part_count; part++) {
                for (let iteration = 0; iteration < Math.ceil(this.period / ring.period); iteration++) {
                    for (let dot of ring.dots) {
                        const iteration_dot_pulse = dot.pulse + iteration * ring.period
                        if (!in_limits(iteration_dot_pulse - part * this.period, 0, this.period)) {
                            continue
                        }
                        this.dots.push({ volume: ring.volume.value, ring_id, period: part_count * this.period, part_id: part, radius_id, symbol: dot.symbol.value, pulse: iteration_dot_pulse, active: dot.active, orig: dot })
                    }
                }
                radius_id++;
            }
        }
        this.radii_count = radius_id
    }

    update_freq(freq) {
        if (checkpoint.ts) {
            checkpoint = processed

            /***/
            console.log(`new freq=${freq} ts=${checkpoint.ts.toFixed(2)} cirlce_id=${checkpoint.circle_id} pulse=${checkpoint.pulse.toFixed(2)}`)
            /***/
        } else {
            /***/
            console.log(`new freq=${freq}`)
            /***/
        }

        if ("text" in this.freq) {
            editor.setValue(this.freq.calc_text(freq))
        } else {
            editor.setValue(Parsed.insert(this.name.text, this.name.pos + this.name.length + 1, " f" + freq))
        }
    }

    update_name(name) {
        if ("text" in this.name) {
            editor.setValue(this.name.calc_text(name))
        } else {
            editor.setValue(Parsed.insert(this.rings[0].name.text, this.rings[0].name.pos, name + ".\n"))
        }
    }

    get period() {
        return this.rings[0].period
    }
    
    get max_period() {
        return Math.max(...this.rings.map(r => Math.ceil(r.period / this.period) * this.period))
    }
    
    get duration() {
        if (this.repeats.value) {
            return this.max_period * this.repeats.value
        } else {
            return Infinity
        }
    }
    
    reset_played() {
        for (let ring of this.rings) {
            for (let dot of ring.dots) {
                dot.played_pulse = null
            }
        }
    }
    
    update(now, elapsed, pulse) {
    
        /***
        let played = false
        let report = now.toFixed(2).padEnd(16, ' ') + elapsed.toFixed(2).padEnd(8, ' ') + pulse.toFixed(2).padStart(8, ' ') + "  " + (this.name.value + "." + Math.floor(pulse/this.max_period)).padEnd(5, ' ')
        /***/

        for (let ring of this.rings) {
            let ring_reported = false
            for (let dot of ring.dots) {
                if (ring.volume.value > 0 && dot.active
                    && in_limits((pulse - dot.pulse) % ring.period, -0.1, 0.3)
                    && (dot.played_pulse ==  null || pulse - dot.played_pulse > ring.period - 0.5)) {

                    /***
                    played = true
                    ring_reported = true
                    const ring_report = `${ring.name.value}-${dot.pulse}:`.padEnd(12, ' ') + `${((pulse - dot.pulse) % ring.period).toFixed(2)}`.padStart(5, ' ') + "[" + `${(dot.played_pulse ==  null ? "---" : (pulse - dot.played_pulse - ring.period).toFixed(2))}`.padStart(5, ' ') + "]"
                    report += ring_report.padEnd(28, ' ')
                    /***/

                    ring.instrument.play(dot.symbol.value, ring.volume.value)
                    dot.played_pulse = pulse
                }
            }

            /***
            if (!ring_reported) {
                report += "".padEnd(28, ' ')
            }
            /***/
        }

        /***
        if (played) {
            console.log(report)
        }
        /***/
    }
    
    draw (ctx, x, y, size, pulse) {
    
        const angle_delta = 2.0 * Math.PI / this.period
        const dot_size = size * 0.012
        const radius_delta = size * 0.38 / Math.max(3, this.radii_count)
        const radius1 = canvas.radius0 + this.radii_count * radius_delta

        ctx.save()
        ctx.translate(x, y)
        for (const dot of this.dots) {
            ctx.save()

            ctx.rotate((-0.5 + 2 * dot.pulse / this.period) * Math.PI)

            const radius = canvas.radius0 + radius_delta * (dot.radius_id + 0.5)
            const playing = dot.active && (checkpoint.ts || checkpoint.pulse) && in_limits((pulse - dot.pulse) % dot.period, -0.1, 0.9)

            ctx.beginPath()
            ctx.arc(0, 0, radius + 0.5 * radius_delta, + angle_delta / 2, - angle_delta / 2, true)
            ctx.arc(0, 0, radius - 0.5 * radius_delta, - angle_delta / 2, + angle_delta / 2, false)
            ctx.closePath()
            if (dot.volume > 0) {
                const color = palette[dot.ring_id % palette.length]
                ctx.fillStyle = playing ? chroma(color).darken().saturate() : chroma.mix("#eee", color, dot.volume/2*0.6 + 0.2)
            } else {
                ctx.fillStyle = "#ddd"
            }
            ctx.fill()

            if (dot.active) {
                ctx.save()
                ctx.translate(radius, 0)
                ctx.beginPath()
                if (dot.symbol == 's' || dot.symbol == 'h') {
                    ctx.moveTo(0 - dot_size, 0 - dot_size)
                    ctx.lineTo(0 - dot_size, 0 + dot_size)
                    ctx.lineTo(0 + dot_size, 0)
                } else if (dot.symbol == 'c') {
                    ctx.moveTo(0 - dot_size, 0 - dot_size)
                    ctx.lineTo(0 - dot_size, 0 + dot_size)
                    ctx.lineTo(0 + dot_size, 0 + dot_size)
                    ctx.lineTo(0 + dot_size, 0 - dot_size)
                } else if (dot.symbol == 'k') {
                    ctx.moveTo(0 - dot_size, 0 - dot_size / 2)
                    ctx.lineTo(0 - dot_size, 0 + dot_size / 2)
                    ctx.lineTo(0 + dot_size, 0 + dot_size / 2)
                    ctx.lineTo(0 + dot_size, 0 - dot_size / 2)
                } else if (dot.symbol == 'd' || dot.symbol == 'b') {
                    ctx.moveTo(0 - dot_size, 0 - dot_size / 2)
                    ctx.lineTo(0 - dot_size, 0 + dot_size / 2)
                    ctx.lineTo(0 + dot_size, 0 + dot_size)
                    ctx.lineTo(0 + dot_size, 0 - dot_size)
                } else {
                    ctx.arc(0, 0, dot_size, 0, 2 * Math.PI)
                }
                ctx.closePath()
                ctx.lineWidth = size * 0.012
                ctx.strokeStyle = background_color
                ctx.stroke()
                ctx.fillStyle = dot.volume > 0 ? "#444" : "#888"
                ctx.fill()
                ctx.restore()
            }

            ctx.restore()
        }

        ctx.strokeStyle = background_color
        ctx.lineWidth = size * 0.006

        for (let i = 0; i < this.period; i++) {
            ctx.save()
            ctx.rotate(2 * Math.PI * (i - 0.5) / this.period)
            ctx.beginPath()
            ctx.moveTo(canvas.radius0, 0)
            ctx.lineTo(radius1, 0)
            ctx.stroke()
            ctx.restore()
        }

        for (let i = 0; i < this.radii_count + 1; i++) {
            ctx.beginPath()
            ctx.arc(0, 0, canvas.radius0 + i * radius_delta, 0, 2 * Math.PI)
            ctx.stroke()
        }

        const shape_size = canvas.radius0 * 0.4
        ctx.beginPath()
        if (checkpoint.ts) {
            ctx.moveTo(0 - shape_size, 0 - shape_size)
            ctx.lineTo(0 - shape_size, 0 + shape_size)
            ctx.lineTo(0 + shape_size, 0 + shape_size)
            ctx.lineTo(0 + shape_size, 0 - shape_size)
        } else {
            ctx.moveTo(0 - 0.7 * shape_size, 0 - 1.2 * shape_size)
            ctx.lineTo(0 - 0.7 * shape_size, 0 + 1.2 * shape_size)
            ctx.lineTo(0 + 1.3 * shape_size, 0)
        }
        ctx.closePath()
        ctx.lineJoin = "round"
        ctx.lineWidth = size * 0.015
        ctx.strokeStyle = "#469"
        ctx.stroke()
        
        ctx.restore()
    }

    draw_debug(ctx, center_x, center_y, size, track) {
        const angle_delta = 2.0 * Math.PI / this.period
        const radius_delta = size * 0.38 / Math.max(3, this.radii_count)

        const x = track.start.x - center_x
        const y = track.start.y - center_y
        const r = Math.sqrt(x * x + y * y)
        const p = (Math.atan2(y, x) / (2 * Math.PI) + 0.25) * this.period

        ctx.save()
        ctx.translate(center_x, center_y)
        ctx.strokeStyle = "red"
        ctx.lineWidth = size * 0.002
        if (r < canvas.radius0) {
            ctx.beginPath()
            ctx.arc(0, 0, canvas.radius0, 0, 2 * Math.PI)
            ctx.stroke()
        } else {

            for (const dot of this.dots) {
                if (in_limits((r - canvas.radius0) / radius_delta - dot.radius_id, 0, 1.0) &&
                    in_limits(diff_period(dot.pulse, p, this.period), -0.5, 0.5)) {

                    const radius = canvas.radius0 + radius_delta * dot.radius_id

                    ctx.save()
                    ctx.rotate((-0.5 + 2 * dot.pulse / this.period) * Math.PI)
                    ctx.beginPath()
                    ctx.arc(0, 0, radius + radius_delta, + angle_delta / 2, - angle_delta / 2, true)
                    ctx.arc(0, 0, radius               , - angle_delta / 2, + angle_delta / 2, false)
                    ctx.closePath()
                    ctx.stroke()
                    ctx.restore()
                }
            }
        }
        ctx.restore()
    }
    

}

var palette = [
"#1f77b4",
"#ff7f0e",
"#2ca02c",
"#d62728",
"#9467bd",
"#8c564b",
"#17becf",
"#e377c2",
"#b4b518",
]

var sounds = {
    'beat':             new Sound('beat-wood.mp3', 0.4),
    'beat_high':        new Sound('beat-wood-high.mp3', 0.15),
    'clap':             new Sound('clap.mp3'),
    'shake':            new Sound('shake.mp3', 0.2),
    'dundunba':         new Sound('dundunba.mp3', 0.25),
    'sangban':          new Sound('sangban.mp3', 0.2),
    'sangban_closed':   new Sound('sangban-closed.mp3', 0.2),
    'kenkeni':          new Sound('kenkeni.mp3', 0.2),
    'djembe_slap':      new Sound('djembe-slap.mp3'),
    'djembe_tone':      new Sound('djembe-tone.mp3'),
    'djembe_base':      new Sound('djembe-base.mp3', 0.6),
}


var instruments = {
    'clave':       new Instrument({ x: sounds.beat, h: sounds.beat_high }),
    'shekere':     new Instrument(sounds.shake),
    'sangban':     new Instrument({ x: sounds.sangban, c: sounds.sangban_closed }),
    'dundunba':    new Instrument(sounds.dundunba),
    'kenkeni':     new Instrument(sounds.kenkeni),
    'bass':        new Instrument({ s: sounds.sangban, c: sounds.sangban_closed, d: sounds.dundunba, k: sounds.kenkeni }),
    'djembe':      new Instrument({ s: sounds.djembe_slap, t: sounds.djembe_tone, b: sounds.djembe_base })
}

function split_tokens(text, sep_re) {
    const splits = text.split(sep_re)
    const res = []
    for (let i = 0, pos = 0, index = 0; i < splits.length; i += 2) {
        const content = splits[i]
        const sep = i + 1 < splits.length ? splits[i + 1] : ""
        res.push({ text, index, pos, content, sep })
        pos += content.length + sep.length
        index++
    }
    return res
}

function split_lines(text) {
    return split_tokens(text, /(\r?\n)/)
}

function split_words(text) {
    return split_tokens(text, /(\s+)/)
}

function split_chars(text) {
    let pos = 0
    const res = []
    for(const content of text.split("")) {
        res.push({ text, index: pos, pos, content, sep: "" })
        pos++
    }
    return res
}

function parse_rhythm (text) {
    let circles = []
    let rings = []
    let symbols = []
    let circle_name = null
    let ring_name = null
    let circle_opts = {}
    let ring_opts = {}

    let freq_overwrite = null

    function valid_circle(name, rings) {
        return name && name.length && rings.length
    }

    function valid_ring(name, symbols) {
        return name && name.value in instruments && symbols.length
    }

    function to_symbols(pos, pattern) {
        let symbols = []
        for (let c of split_chars(pattern)) {
            if (!/\s+/.test(c.content)) {
                symbols.push(new Parsed(text, pos + c.pos, c.content.length, c.content))
            }
        }
        return symbols
    }

    for (let line of split_lines(text)) {
        if (line.index == 0 && /^#!/.test(line.content)) {
            for (let token of split_words(line.content.substring(2))) {
                const res = token.content.match(/^f(\d*\.?\d+)$/)
                if (res) {
                    freq_overwrite = new Parsed(text, line.pos + token.pos + 3, res[1].length, parseFloat(res[1]))
                }
            }
        } else {
            const cleaned = line.content.replace(/#.*$/, "")

            let res = cleaned.match(/^(\d+)\.(.*)$/)
            if (res) {
                if (valid_ring(ring_name, symbols)) {
                    rings.push(new Ring(ring_name, instruments[ring_name.value], symbols, ring_opts))
                }
                if (valid_circle(circle_name, rings)) {
                    circles.push(new Circle(circle_name, rings, circle_opts))
                }
                circle_name = new Parsed(text, line.pos, res[1].length, res[1])
                symbols = []
                ring_name = null
                ring_opts = {}
                rings = []
                circle_opts = {}

                const opt_pos = line.pos + res[1].length + 1
                for (let token of split_words(res[2])) {
                    let res = token.content.match(/^f(\d*\.?\d+)$/)
                    if (res) {
                        circle_opts.freq = new Parsed(text, opt_pos + token.pos + 1, res[1].length, parseFloat(res[1]))
                        continue
                    }
                    res = token.content.match(/^x(\d+)$/)
                    if (res) {
                        circle_opts.repeats = new Parsed(text, opt_pos + token.pos + 1, res[1].length, parseInt(res[1]))
                        continue
                    }
                }
                continue
            }

            res = cleaned.match(/^([^:\s][^:]*):(.*)$/)
            if (res) {
                if (valid_ring(ring_name, symbols)) {
                    rings.push(new Ring(ring_name, instruments[ring_name.value], symbols, ring_opts))
                }
                const tokens = split_words(res[1])
                ring_name = new Parsed(text, line.pos + tokens[0].pos, tokens[0].content.length, tokens[0].content)
                symbols = to_symbols(line.pos + res[1].length + 1, res[2])
                ring_opts = {}
                for (let token of tokens.slice(1)) {
                    const res = token.content.match(/^v(\d*\.?\d+)$/)
                    if (res) {
                        ring_opts.volume = new Parsed(text, line.pos + token.pos + 1, res[1].length, parseFloat(res[1]))
                    }
                }
                continue
            }

            symbols = symbols.concat(to_symbols(line.pos, cleaned))
        }
    }

    if (valid_ring(ring_name, symbols)) {
        rings.push(new Ring(ring_name, instruments[ring_name.value], symbols, ring_opts))
    }

    if (valid_circle(circle_name, rings)) {
        circles.push(new Circle(circle_name, rings, circle_opts))
    } else if (rings.length) {
        circles.push(new Circle({ value: "" }, rings))
    }
    return circles
}

const rhythm_collection = {
    "djole": `\
1. f6.8 x2
shekere:   x... x... x... x...
2. f6.9 x4
shekere:   x... x... x... x...
sangban:   c... x... c... x...
dundunba:  x... .... x.x. ....
3. f7.0 x4
shekere:   x... x... x... x...
bass:      d... s... d.d. s...
kenkeni v0.5:
           ..xx ..xx ..xx ..xx
4. f7.1 x8
shekere:   x... x... x... x...
bass:      d... s... d.d. s...
kenkeni v0.5:
           ..xx ..xx ..xx ..xx
djembe:    tttt b... t.t. b...
5. f7.2 x8
shekere:   x... x... x... x...
bass:      d.kk s.kk d.dk s.kk
djembe:    ttst tstt stts ttst
           tstt s.ss ttst tss.
`
}

const compos_name = "djole"
const text = window.localStorage.getItem(compos_name) || rhythm_collection[compos_name] || ""


var circles = parse_rhythm(text)

function fix_circles() {
    if (circles.length) {
        for (let circle_id = 0; circle_id < circles.length; circle_id++) {
            if (circles[circle_id].name.value != circle_id + 1) {
                circles[circle_id].update_name(circle_id + 1)
            }
        }
    } else {
        editor.setValue("1.\nshekere:   x... x... x... x...\n")
    }
}

CodeMirror.defineMode("rhythm", function() {
    return {
        token: function(stream) {
            if (stream.eatSpace()) {
                return null
            }
            if (stream.match("#")) {
                stream.skipToEnd();
                return "comment";
            }
            for (const word of ["djembe", "dundunba", "dununba", "sangban", "kenkeni", "shekere", "clave", "bass"]) {
                if (stream.match(word, true, true)) {
                    return "keyword"
                }
            }
            if (stream.match(":")) {
                return "punctuation"
            }
            if (stream.match(/v\d*\.?\d+/)) {
                return "parameter"
            }
            stream.eatWhile(/\S/)
            return null;
        }
    }
})

var editor = CodeMirror(document.getElementById("editor"), { mode: "rhythm", value: text, scrollbarStyle: "overlay" })
function in_limits(x, l1, l2) {
    return x >= l1 && x < l2
}

function clamp(x, min, max) {
    return Math.min(Math.max(x, min), max)
};

function process(ts) {
    let { pulse, circle_id } = checkpoint
    if (checkpoint.ts) {
        let elapsed = ts - checkpoint.ts
        pulse += elapsed * circles[circle_id].freq.value / 1000
        while (circle_id < circles.length && pulse >= circles[circle_id].duration) {
            const left = (pulse - circles[circle_id].duration) / circles[circle_id].freq.value * 1000
            circle_id ++
            if (circle_id >= circles.length) {
                circle_id = 0
                circles.forEach(c => c.reset_played())
                console.log(`restarting ts=${ts.toFixed(2)}`)
                checkpoint.ts = ts
                elapsed = 0
            }
            pulse = left * circles[circle_id].freq.value / 1000
        }
        circles[circle_id].update(ts, elapsed, pulse)
    }

    draw(circle_id, pulse, ts)
    window.requestAnimationFrame(process)
    processed = { ts, circle_id, pulse }
}

function stop() {
    console.log(`stop ts=${checkpoint.ts.toFixed(2)} cirlce_id=${processed.circle_id}`)
    checkpoint.circle_id = processed.circle_id
    checkpoint.ts = 0
    checkpoint.pulse = 0
    circles.forEach(c => {c.reset_played()})
}

function start() {
    checkpoint.ts = performance.now() + 10.0
    console.log(`starting ts=${checkpoint.ts.toFixed(2)}  cirlce_id=${checkpoint.circle_id} pulse=${checkpoint.pulse.toFixed(2)}`)
}

function pause() {
    checkpoint = processed
    console.log(`pause ts=${checkpoint.ts.toFixed(2)} cirlce_id=${checkpoint.circle_id} pulse=${checkpoint.pulse.toFixed(2)}`)
    checkpoint.ts = 0
}

function toggle_play() {
    if (checkpoint.ts) {
        stop()
    } else {
        start()
    }
}

function draw_track(ctx, track, size, now) {
    if (track.points.length) {
        ctx.lineWidth = size * 0.050
        ctx.lineCap = "round"
        let prev_point = track.points[0]
        for (const point of track.points) {
            const life = (point.ts - now + 200) / 200
            if (life > 0) {
                ctx.beginPath()
                ctx.moveTo(prev_point.x, prev_point.y)
                ctx.lineTo(point.x, point.y)
                ctx.strokeStyle = 'rgba(0, 255, 0, ' + life + ')'
                ctx.stroke()
            }
            prev_point = point
        }
    }

    if ("drag" in track) {
        ctx.beginPath()
        ctx.moveTo(track.start.x, track.start.y)
        if (track.drag == "x") {
            ctx.lineTo(track.end.x, track.start.y)
        } else {
            ctx.lineTo(track.start.x, track.end.y)
        }
        ctx.strokeStyle = "blue"
        ctx.lineWidth = canvas.size * 0.020
        ctx.stroke()
    }
}

function draw(circle_id, pulse, now) {

    const ctx = canvas.getContext('2d')
    ctx.clearRect(0, 0, canvas.width, canvas.height)

    if (!circles.length) {
        return
    }

    circles[circle_id].draw(ctx, canvas.width / 2, canvas.height / 2, canvas.size, pulse)

    const touch_ids = Object.keys(tracks)

    if (touch_ids.length == 1) {
        const track = tracks[touch_ids[0]]
        circles[circle_id].draw_debug(ctx, canvas.width / 2, canvas.height / 2, canvas.size, track)
        draw_track(ctx, track, canvas.size, now)

        if ("planned_freq" in track && track.planned_freq.circle_id == circle_id) {
            ctx.font = 'bold 64px sans-serif'
            ctx.fillStyle = "blue"
            ctx.strokeStyle = background_color
            ctx.lineWidth = 5
            let str = "f" + track.planned_freq.value
            ctx.strokeText(str, 8, 72)
            ctx.fillText(str, 8, 72)
        }

        if ("planned_volume" in track && track.planned_volume.circle_id == circle_id) {
            ctx.font = 'bold 64px sans-serif'
            const str = "v" + track.planned_volume.value
            ctx.fillStyle = "green"
            ctx.strokeStyle = background_color
            ctx.lineWidth = 5
            ctx.strokeText(str, 8, 72)
            ctx.fillText(str, 8, 72)
        }
    }
}

function resize() {
    reset_tracks()
    canvas.size = Math.min(window.innerWidth, window.innerHeight)
    const vertical = window.innerWidth > window.innerHeight
    if (editor.hasFocus()) {
        canvas.size /= vertical ? 2 : 4
    }
    document.body.className = vertical ? "vertical" : "horizontal"
    canvas.width = canvas.size
    canvas.height = canvas.size
    canvas.radius0 = canvas.size * 0.10
}

function on_editor_change(editor) {
    const text = editor.getValue()
    circles = parse_rhythm(text)
    fix_circles()
    window.localStorage.setItem(compos_name, text)
}


class Track {
    constructor(start_x, start_y, ts) {
        this.points = [{ x: start_x, y: start_y, ts: ts }]
    }
    get start() {
        return this.points[0]
    }
    get end() {
        return this.points[this.points.length - 1]
    }
    add_point(x, y, ts) {
        this.points.push({ x: x, y: y, ts: ts })
        if (!("drag" in this)) {
            if (Math.abs(y - this.start.y) > 20) {
                this.drag = "y"
            } else if (Math.abs(x - this.start.x) > 20) {
                this.drag = "x"
            }
        }
    }
}

var tracks

function on_mousedown(e) {
    e.preventDefault()
    if (editor.hasFocus()) {
        editor.getInputField().blur()
        reset_tracks()
        return
    }
    start_track("m", e.clientX, e.clientY, e.timeStamp)
}

function diff_period(x1, x2, period) {
    const d = (x2 - x1) % period
    if (d < -0.5 * period) {
        return d + period
    } else if (d > 0.5 * period) {
        return d - period
    } else {
        return d
    }
}

function on_mousemove(e) {
    e.preventDefault()
    update_track("m", e.clientX, e.clientY, e.timeStamp)
}

function on_mouseup(e) {
    e.preventDefault()
    end_tracks()
}


function start_track(id, x, y, ts) {
    tracks[id] = new Track(x - canvas.getBoundingClientRect().left, y - canvas.getBoundingClientRect().top, ts)
}

function update_track(id, x, y, ts) {
    if (id in tracks) {
        tracks[id].add_point(x, y, ts)
    }

    let touch_ids = Object.keys(tracks)
    if (touch_ids.length == 1) {
        let track = tracks[touch_ids[0]]
        const x = track.start.x - canvas.width / 2
        const y = track.start.y - canvas.height / 2
        const r = Math.sqrt(x * x + y * y)

        const circle = circles[processed.circle_id]
        
        if (r < canvas.radius0) {
            if ("drag" in track) {
                if(track.drag == "y") {
                    track.planned_freq = { circle_id: processed.circle_id, value: clamp((circle.freq.value - (track.end.y - track.start.y) * canvas.size * 0.00002).toFixed(1), 1, 20) }
                }
            }
        } else {
            const radius_delta = canvas.size * 0.38 / Math.max(3, circle.radii_count)
            for (const dot of circle.dots) {
                if (in_limits((r - canvas.radius0) / radius_delta - dot.radius_id, 0, 1.0)) {
                    if (track.drag == "y") {
                        const ring = circle.rings[dot.ring_id]
                        track.planned_volume = { circle_id: processed.circle_id, ring_id: dot.ring_id, value: clamp((ring.volume.value - (track.end.y - track.start.y) * canvas.size * 0.00002).toFixed(1), 0.0, 2.0) }
                    }
                    break
                }
            }
        }
    }
}

function reset_tracks() {
    tracks = {}
}

function end_tracks() {
    let touch_ids = Object.keys(tracks)
    if (touch_ids.length == 1) {
        let track = tracks[touch_ids[0]]
        const x = track.start.x - canvas.width / 2
        const y = track.start.y - canvas.height / 2
        const r = Math.sqrt(x * x + y * y)

        const circle = circles[processed.circle_id]

        if (r < canvas.radius0) {
            if ("drag" in track) {
                if(track.drag == "y" && "planned_freq" in track && track.planned_freq.circle_id == processed.circle_id) {
                    circle.update_freq(track.planned_freq.value)
                }
            } else {
                    toggle_play()
            }
        } else {
            const radius_delta = canvas.size * 0.38 / Math.max(3, circle.radii_count)
            const p = (Math.atan2(y, x) / (2 * Math.PI) + 0.25) * circle.period
            for (const dot of circle.dots) {
                if (in_limits((r - canvas.radius0) / radius_delta - dot.radius_id, 0, 1.0) &&
                    in_limits(diff_period(dot.pulse, p, circle.period), -0.5, 0.5)) {

                    const ring = circle.rings[dot.ring_id]
                    if ("drag" in track) {
                        if (track.drag == "y" && "planned_volume" in track && track.planned_volume.circle_id == processed.circle_id && track.planned_volume.ring_id == dot.ring_id) {
                            ring.update_volume(track.planned_volume.value)
                        }
                    } else {
                        dot.orig.update_symbol(ring.instrument.next_symbol(dot.symbol))
                    }
                    break
                }
            }
        }
    }
    reset_tracks()
}

function on_touchstart(e) {
    e.preventDefault()
    if (editor.hasFocus()) {
        editor.getInputField().blur()
        reset_tracks()
        return
    }
    for (let t of e.changedTouches) {
        start_track(t.identifier, t.clientX, t.clientY, e.timeStamp)
    }
    if (Object.keys(tracks).length > 1) {
        reset_tracks()
    }
}

function on_touchmove(e) {
    e.preventDefault()
    for (let t of e.changedTouches) {
        update_track(t.identifier, t.clientX - canvas.getBoundingClientRect().left, t.clientY - canvas.getBoundingClientRect().top, e.timeStamp)
    }
}

function on_touchend(e) {
    e.preventDefault()
    end_tracks()
}

function on_touchcancel(e) {
    if(e.cancelable) {
        e.preventDefault()
    }
    reset_tracks()
}

function on_editor_focus() {
    stop()
    resize()
}

function on_editor_blur() {
    resize()
}

window.requestAnimationFrame(process)
window.addEventListener('resize', resize, false)
canvas.addEventListener("mousedown",   on_mousedown)
canvas.addEventListener("mousemove",   on_mousemove)
canvas.addEventListener("mouseup",     on_mouseup)
canvas.addEventListener("touchstart",  on_touchstart)
canvas.addEventListener("touchmove",   on_touchmove)
canvas.addEventListener("touchend",    on_touchend)
canvas.addEventListener("touchcancel", on_touchcancel)
document.addEventListener('DOMContentLoaded', resize)
editor.on("focus", on_editor_focus)
editor.on("blur", on_editor_blur)
editor.on("changes", on_editor_change)

var checkpoint = { circle_id: 0, ts: 0, pulse: 0 }
var processed = checkpoint

fix_circles()

</script>
</body>
</html>
