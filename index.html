<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.1.2/howler.core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.48.4/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.48.4/addon/scroll/simplescrollbars.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.1.0/chroma.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.48.4/codemirror.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.48.4/addon/scroll/simplescrollbars.min.css" />
<style>
* {
    margin: 0;
    padding: 0;
}
html, body {
    margin: 0;
    width: 100%;
    height: 100%;
    border: 0;
    overflow: hidden;
    display: block;
}
body {
    display: flex;
    align-items: center;
}
body.horizontal {
    flex-direction: column;
}
body.vertical {
    flex-direction: row;
}
#editor {
    flex-grow: 1;
    align-self: stretch;
}
#canvas {
}
.CodeMirror {
    font-size: 20px;
}

.CodeMirror {
    min-height: 100%;
    max-height: 100%;
    min-width: 100%;
    max-width: 100%;
}

.cm-s-default .cm-keyword     { color: blue; }
.cm-s-default .cm-punctuation { color: red;  }
.cm-s-default .cm-comment     { color: #488; }
.cm-s-default .cm-parameter   { color: #a1a; }

</style>
</head>
<body>
<canvas id=canvas>
</canvas>
<div id=editor>
</div>

<script>

"use strict";

var canvas = document.getElementById("canvas")

var background_color = "white"

class Dot {
    constructor(pulse, symbol) {
        this.pulse = pulse
        this.symbol = symbol
        this.played_pulse = null
    }
    get active() {
        return this.symbol.value != '.'
    }

    update_symbol(symbol) {
        editor.setValue(this.symbol.calc_text(symbol))
    }
}

class Ring {
    constructor(name, instrument, symbols, opts) {
        this.name = name
        this.instrument = instrument
        opts = Object.assign({ volume: { value: 1.0 } }, opts);
        this.volume = opts.volume
        this.dots = []
        let pulse = 0
        for (const symbol of symbols) {
            this.dots.push(new Dot(pulse, symbol))
            pulse++
        }
        this.period = this.dots.length
    }

    update_volume(volume) {
        if ("text" in this.volume) {
            editor.setValue(this.volume.calc_text(volume))
        } else {
            editor.setValue(this.name.text.slice(0, this.name.pos + this.name.length) + " v" + volume + (this.name.text.slice(this.name.pos + this.name.length)))
        }
    }

    update_name(name) {
        editor.setValue(this.name.calc_text(name))
    }
}

class Sound extends Howl {
    constructor(src, volume_factor) {
        super({ src })
        this.volume_factor = volume_factor === undefined ? 1.0 : volume_factor
        this.volume_factor *= 0.5
    }
    play(volume) {
        super.volume(volume * this.volume_factor)
        super.play()
    }
}

class Instrument {
    constructor(sound) {
        this.sound = sound
        if (this.sound instanceof Sound) {
            this.symbols = ["x"]
        } else {
            this.symbols = Object.keys(this.sound)
        }
    }

    play(symbol, volume) {
        let sound = this.sound instanceof Sound ? this.sound : this.sound[symbol]
        sound.play(volume)
    }

    next_symbol(symbol) {
        const symbol_id = this.symbols.indexOf(symbol)
        return symbol_id == this.symbols.length - 1 ? "." : this.symbols[symbol_id + 1]
    }
}

class Parsed {
    constructor(text, pos, length, value) {
        this.text = text
        this.pos = pos
        this.length = length
        this.value = value
    }

    calc_text(new_value) {
        return this.text.slice(0, this.pos) + new_value + this.text.slice(this.pos + this.length)
    }
}

var palette = [
"#1f77b4",
"#ff7f0e",
"#2ca02c",
"#d62728",
"#9467bd",
"#8c564b",
"#17becf",
"#e377c2",
"#b4b518",
]

var freq = { value: 7.0 }

function update_freq(new_freq) {
    if (start_ts) {
        const ts = performance.now()
        pulse_counter += (ts - start_ts) * freq.value / 1000
        start_ts = ts

        /***/
        console.log(`new freq=${new_freq} ts=${ts.toFixed(2)} pulse=${pulse_counter.toFixed(2)}`)
        /***/
    } else {
        /***/
        console.log(`new freq=${new_freq}`)
        /***/
    }

    if ("text" in freq) {
        editor.setValue(freq.calc_text(new_freq))
    } else {
        const text = editor.getValue()
        const line = text.split(/(\r?\n)/, 1)[0]
        const pos = /^#!/.test(line) ? 2 : 0
        editor.setValue("#! f" + new_freq + (pos == 0 ? "\n" : line.length == 2 || /\s+/.test(line[2]) ? "" : " ") + text.slice(pos))
    }
}

var sounds = {
    'beat':             new Sound('beat-wood.mp3', 0.4),
    'beat_high':        new Sound('beat-wood-high.mp3', 0.15),
    'clap':             new Sound('clap.mp3'),
    'shake':            new Sound('shake.mp3', 0.2),
    'dundunba':         new Sound('dundunba.mp3', 0.25),
    'sangban':          new Sound('sangban.mp3', 0.2),
    'sangban_closed':   new Sound('sangban-closed.mp3', 0.2),
    'kenkeni':          new Sound('kenkeni.mp3', 0.2),
    'djembe_slap':      new Sound('djembe-slap.mp3'),
    'djembe_tone':      new Sound('djembe-tone.mp3'),
    'djembe_base':      new Sound('djembe-base.mp3', 0.6),
}


var instruments = {
    'clave':       new Instrument({ x: sounds.beat, h: sounds.beat_high }),
    'shekere':     new Instrument(sounds.shake),
    'sangban':     new Instrument({ x: sounds.sangban, c: sounds.sangban_closed }),
    'dundunba':    new Instrument(sounds.dundunba),
    'kenkeni':     new Instrument(sounds.kenkeni),
    'bass':        new Instrument({ s: sounds.sangban, c: sounds.sangban_closed, d: sounds.dundunba, k: sounds.kenkeni }),
    'djembe':      new Instrument({ s: sounds.djembe_slap, t: sounds.djembe_tone, b: sounds.djembe_base })
}

function split_tokens(text, sep_re) {
    const splits = text.split(sep_re)
    const res = []
    for (let i = 0, pos = 0, index = 0; i < splits.length; i += 2) {
        const content = splits[i]
        const sep = i + 1 < splits.length ? splits[i + 1] : ""
        res.push({ text, index, pos, content, sep })
        pos += content.length + sep.length
        index++
    }
    return res
}

function split_lines(text) {
    return split_tokens(text, /(\r?\n)/)
}

function split_words(text) {
    return split_tokens(text, /(\s+)/)
}

function split_chars(text) {
    let pos = 0
    const res = []
    for(const content of text.split("")) {
        res.push({ text, index: pos, pos, content, sep: "" })
        pos++
    }
    return res
}

function parse_rhythm (text) {
    let rings = []
    let name = ""
    let symbols = []
    let opts = {}
    
    freq = { value: freq.value }

    function valid(name, symbols) {
        return (name.value in instruments) && symbols.length
    }

    function to_symbols(pos, pattern) {
        let symbols = []
        for (let c of split_chars(pattern)) {
            if (!/\s+/.test(c.content)) {
                symbols.push(new Parsed(text, pos + c.pos, c.content.length, c.content))
            }
        }
        return symbols
    }

    for (let line of split_lines(text)) {
        if (line.index == 0 && /^#!/.test(line.content)) {
            for (let token of split_words(line.content.substring(2))) {
                const res = token.content.match(/^f(\d*\.?\d+)$/)
                if (res) {
                    freq = new Parsed(text, line.pos + token.pos + 3, res[1].length, parseFloat(res[1]))
                }
            }
        } else {
            const cleaned = line.content.replace(/#.*/, "")
            const res = cleaned.match(/([^:\s][^:]*):(.*)/)
            if (res) {
                if (valid(name, symbols)) {
                    rings.push(new Ring(name, instruments[name.value], symbols, opts))
                }
                const tokens = split_words(res[1])
                name = new Parsed(text, line.pos + tokens[0].pos, tokens[0].content.length, tokens[0].content)
                symbols = to_symbols(line.pos + res[1].length + 1, res[2])
                opts = {}
                for (let token of tokens.slice(1)) {
                    const res = token.content.match(/v(\d*\.?\d+)/)
                    if (res) {
                        opts.volume = new Parsed(text, line.pos + token.pos + 1, res[1].length, parseFloat(res[1]))
                    }
                }
            } else {
                symbols = symbols.concat(to_symbols(line.pos, cleaned))
            }
        }
    }
    if (valid(name, symbols)) {
        rings.push(new Ring(name, instruments[name.value], symbols, opts))
    }
    return rings
}


const text = window.localStorage.getItem("text") || `\
shekere:  x... x... x... x...
sangban:  c... x...
dundunba: x... .... x.x. ....
#djembe:   s..s s.tt
djembe:  #tts. ts.. s..t .st.
         #.s.. t.ss ..t. ..ss
         #tts. .stt s..s ..s.
         #.tss t.tt ..st ttss
          ttst tstt stts ttst
          tstt s.ss ttst tss.
`

var rings = parse_rhythm(text)

CodeMirror.defineMode("rhythm", function() {
    return {
        token: function(stream) {
            if (stream.eatSpace()) {
                return null
            }
            if (stream.match("#")) {
                stream.skipToEnd();
                return "comment";
            }
            for (const word of ["djembe", "dundunba", "dununba", "sangban", "kenkeni", "shekere", "clave", "bass"]) {
                if (stream.match(word, true, true)) {
                    return "keyword"
                }
            }
            if (stream.match(":")) {
                return "punctuation"
            }
            if (stream.match(/v\d*\.?\d+/)) {
                return "parameter"
            }
            stream.eatWhile(/\S/)
            return null;
        }
    }
})

var editor = CodeMirror(document.getElementById("editor"), { mode: "rhythm", value: text, scrollbarStyle: "overlay" })


function in_limits(x, l1, l2) {
    return x >= l1 && x < l2
}

function clamp(x, min, max) {
    return Math.min(Math.max(x, min), max)
};

function update(now, elapsed, pulse) {

    /***
    let played = false
    let report = (`${now.toFixed(2)}`).padEnd(16, ' ') + (`${elapsed.toFixed(2)}`).padEnd(8, ' ') + (`${pulse.toFixed(2)}:`).padStart(8, ' ')
    /***/

    for (let ring of rings) {
        let ring_reported = false
        for (let dot of ring.dots) {
            if (ring.volume.value > 0 && dot.active
                && in_limits((pulse - dot.pulse) % ring.period, -0.05, 0.2)
                && (dot.played_pulse ==  null || pulse - dot.played_pulse > ring.period - 0.1)) {

                /***
                played = true
                ring_reported = true
                const ring_report = `${ring.name.value}-${dot.pulse}:`.padEnd(12, ' ') + `${((pulse - dot.pulse) % ring.period).toFixed(2)}`.padStart(5, ' ') + "[" + `${(dot.played_pulse ==  null ? "---" : (pulse - dot.played_pulse - ring.period).toFixed(2))}`.padStart(5, ' ') + "]"
                report += ring_report.padEnd(28, ' ')
                /***/

                ring.instrument.play(dot.symbol.value, ring.volume.value)
                dot.played_pulse = pulse
            }
        }

        /***
        if (!ring_reported) {
            report += "".padEnd(28, ' ')
        }
        /***/
    }

    /***
    if (played) {
        console.log(report)
    }
    /***/
}

function process(ts) {
    const elapsed = ts - start_ts
    const pulse = pulse_counter + elapsed * freq.value / 1000

    if (start_ts) {
        update(ts, elapsed, pulse)
    }
    draw(start_ts ? pulse : pulse_counter, ts)
    window.requestAnimationFrame(process)
}

function stop() {
    console.log(`stopping ts=${performance.now().toFixed(2)}`)
    start_ts = 0;
    pulse_counter = 0
    for (let ring of rings) {
        for (let dot of ring.dots) {
            dot.played_pulse = null
        }
    }
}

function start() {
    start_ts = performance.now() + 10.0
    console.log(`starting ts=${start_ts.toFixed(2)}`)
}

function pause() {
    const ts = performance.now()
    pulse_counter += (ts - start_ts) * freq.value / 1000
    console.log(`pause ts=${ts.toFixed(2)} pulse=${pulse_counter.toFixed(2)}`)
    start_ts = 0;
}

function toggle_play() {
    if (start_ts) {
        stop()
    } else {
        start()
    }
}

function* dots(rings, period) {
    let radius_id = 0
    for (const [ring_id, ring] of rings.entries()) {
        const part_count = Math.ceil(ring.period / period)
        for (let part = 0; part < part_count; part++) {
            for (let iteration = 0; iteration < Math.ceil(period / ring.period); iteration++) {
                for (let dot of ring.dots) {
                    const iteration_dot_pulse = dot.pulse + iteration * ring.period
                    if (!in_limits(iteration_dot_pulse - part * period, 0, period)) {
                        continue
                    }
                    yield { volume: ring.volume.value, ring_id, period: part_count * period, part_id: part, radius_id, symbol: dot.symbol.value, pulse: iteration_dot_pulse, active: dot.active, orig: dot }
                }
            }
            radius_id++;
        }
    }
}

function draw(pulse, now) {

    const ctx = canvas.getContext('2d')
    ctx.clearRect(0, 0, canvas.width, canvas.height)
    if (!rings.length) {
        return
    }

    const period = rings[0].period
    const radii_count = rings.reduce((count, ring) => count + Math.ceil(ring.period / period), 0)
    const angle_delta = 2.0 * Math.PI / period
    const dot_size = canvas.size * 0.012
    const radius_delta = canvas.size * 0.38 / Math.max(3, radii_count)
    const radius1 = canvas.radius0 + radii_count * radius_delta

    ctx.save()
    ctx.translate(canvas.width / 2, canvas.height / 2)
    for (const dot of dots(rings, period)) {
        ctx.save()

        ctx.rotate((-0.5 + 2 * dot.pulse / period) * Math.PI)

        const radius = canvas.radius0 + radius_delta * (dot.radius_id + 0.5)
        const playing = dot.active && (start_ts || pulse_counter) && in_limits((pulse - dot.pulse) % dot.period, -0.1, 0.9)

        ctx.beginPath()
        ctx.arc(0, 0, radius + 0.5 * radius_delta, + angle_delta / 2, - angle_delta / 2, true)
        ctx.arc(0, 0, radius - 0.5 * radius_delta, - angle_delta / 2, + angle_delta / 2, false)
        ctx.closePath()
        if (dot.volume > 0) {
            const color = palette[dot.ring_id % palette.length]
            ctx.fillStyle = playing ? chroma(color).darken().saturate() : chroma.mix("#eee", color, dot.volume/2*0.6 + 0.2)
        } else {
            ctx.fillStyle = "#ddd"
        }
        ctx.fill()

        if (dot.active) {
            ctx.save()
            ctx.translate(radius, 0)
            ctx.beginPath()
            if (dot.symbol == 's' || dot.symbol == 'h') {
                ctx.moveTo(0 - dot_size, 0 - dot_size)
                ctx.lineTo(0 - dot_size, 0 + dot_size)
                ctx.lineTo(0 + dot_size, 0)
            } else if (dot.symbol == 'c') {
                ctx.moveTo(0 - dot_size, 0 - dot_size)
                ctx.lineTo(0 - dot_size, 0 + dot_size)
                ctx.lineTo(0 + dot_size, 0 + dot_size)
                ctx.lineTo(0 + dot_size, 0 - dot_size)
            } else if (dot.symbol == 'k') {
                ctx.moveTo(0 - dot_size, 0 - dot_size / 2)
                ctx.lineTo(0 - dot_size, 0 + dot_size / 2)
                ctx.lineTo(0 + dot_size, 0 + dot_size / 2)
                ctx.lineTo(0 + dot_size, 0 - dot_size / 2)
            } else if (dot.symbol == 'd' || dot.symbol == 'b') {
                ctx.moveTo(0 - dot_size, 0 - dot_size / 2)
                ctx.lineTo(0 - dot_size, 0 + dot_size / 2)
                ctx.lineTo(0 + dot_size, 0 + dot_size)
                ctx.lineTo(0 + dot_size, 0 - dot_size)
            } else {
                ctx.arc(0, 0, dot_size, 0, 2 * Math.PI)
            }
            ctx.closePath()
            ctx.lineWidth = canvas.size * 0.012
            ctx.strokeStyle = background_color
            ctx.stroke()
            ctx.fillStyle = dot.volume > 0 ? "#444" : "#888"
            ctx.fill()
            ctx.restore()
        }

        ctx.restore()
    }

    ctx.strokeStyle = background_color
    ctx.lineWidth = canvas.size * 0.006

    for (let i = 0; i < period; i++) {
        ctx.save()
        ctx.rotate(2 * Math.PI * (i - 0.5) / period)
        ctx.beginPath()
        ctx.moveTo(canvas.radius0, 0)
        ctx.lineTo(radius1, 0)
        ctx.stroke()
        ctx.restore()
    }

    for (let i = 0; i < radii_count + 1; i++) {
        ctx.beginPath()
        ctx.arc(0, 0, canvas.radius0 + i * radius_delta, 0, 2 * Math.PI)
        ctx.stroke()
    }

    const shape_size = canvas.radius0 * 0.4
    ctx.beginPath()
    if (start_ts) {
        ctx.moveTo(0 - shape_size, 0 - shape_size)
        ctx.lineTo(0 - shape_size, 0 + shape_size)
        ctx.lineTo(0 + shape_size, 0 + shape_size)
        ctx.lineTo(0 + shape_size, 0 - shape_size)
    } else {
        ctx.moveTo(0 - 0.7 * shape_size, 0 - 1.2 * shape_size)
        ctx.lineTo(0 - 0.7 * shape_size, 0 + 1.2 * shape_size)
        ctx.lineTo(0 + 1.3 * shape_size, 0)
    }
    ctx.closePath()
    ctx.lineJoin = "round"
    ctx.lineWidth = canvas.size * 0.015
    ctx.strokeStyle = "#469"
    ctx.stroke()

    const touch_ids = Object.keys(tracks)

    if (touch_ids.length == 1) {
        const track = tracks[touch_ids[0]]
        const x = track.start.x - canvas.width / 2
        const y = track.start.y - canvas.height / 2
        const r = Math.sqrt(x * x + y * y)
        const p = (Math.atan2(y, x) / (2 * Math.PI) + 0.25) * period

        ctx.strokeStyle = "red"
        ctx.lineWidth = canvas.size * 0.002
        if (r < canvas.radius0) {
            ctx.beginPath()
            ctx.arc(0, 0, canvas.radius0, 0, 2 * Math.PI)
            ctx.stroke()
        } else {

            for (const dot of dots(rings, period)) {
                if (in_limits((r - canvas.radius0) / radius_delta - dot.radius_id, 0, 1.0) &&
                    in_limits(diff_period(dot.pulse, p, period), -0.5, 0.5)) {

                    const radius = canvas.radius0 + radius_delta * dot.radius_id

                    ctx.save()
                    ctx.rotate((-0.5 + 2 * dot.pulse / period) * Math.PI)
                    ctx.beginPath()
                    ctx.arc(0, 0, radius + radius_delta, + angle_delta / 2, - angle_delta / 2, true)
                    ctx.arc(0, 0, radius               , - angle_delta / 2, + angle_delta / 2, false)
                    ctx.closePath()
                    ctx.stroke()
                    ctx.restore()
                }
            }
        }
    }

    ctx.restore()

    
    if (touch_ids.length == 1) {
        const track = tracks[touch_ids[0]]

        if (track.points.length) {
            ctx.lineWidth = canvas.size * 0.050
            ctx.lineCap = "round"
            let prev_point = track.points[0]
            for (const point of track.points) {
                const life = (point.ts - now + 200) / 200
                if (life > 0) {
                    ctx.beginPath()
                    ctx.moveTo(prev_point.x, prev_point.y)
                    ctx.lineTo(point.x, point.y)
                    ctx.strokeStyle = 'rgba(0, 255, 0, ' + life + ')'
                    ctx.stroke()
                }
                prev_point = point
            }
        }

        if ("drag" in track) {
            const x = track.start.x - canvas.width / 2
            const y = track.start.y - canvas.height / 2
            const r = Math.sqrt(x * x + y * y)

            ctx.beginPath()
            ctx.moveTo(track.start.x, track.start.y)
            if (track.drag == "x") {
                ctx.lineTo(track.end.x, track.start.y)
            } else {
                ctx.lineTo(track.start.x, track.end.y)
            }
            ctx.strokeStyle = "blue"
            ctx.lineWidth = canvas.size * 0.020
            ctx.stroke()

            if (r < canvas.radius0) {
                if (track.drag == "y") {
                    ctx.font = 'bold 64px sans-serif'
                    ctx.fillStyle = "blue"
                    ctx.strokeStyle = background_color
                    ctx.lineWidth = 5
                    let str = "f" + clamp((freq.value - (track.end.y - track.start.y) * canvas.size * 0.00002).toFixed(1), 1, 20)
                    ctx.strokeText(str, 8, 72)
                    ctx.fillText(str, 8, 72)
                }
            } else {
                for (const dot of dots(rings, period)) {
                    if (in_limits((r - canvas.radius0) / radius_delta - dot.radius_id, 0, 1.0)) {
                        if (track.drag == "y") {
                            const ring = rings[dot.ring_id]
                            ctx.font = 'bold 64px sans-serif'
                            const volume = clamp((ring.volume.value - (track.end.y - track.start.y) * canvas.size * 0.00002).toFixed(1), 0.0, 2.0)
                            const str = "v" + volume
                            ctx.fillStyle = "green"
                            ctx.strokeStyle = background_color
                            ctx.lineWidth = 5
                            ctx.strokeText(str, 8, 72)
                            ctx.fillText(str, 8, 72)
                        }
                        break
                    }
                }
            }
        }
    }
}

function resize() {
    reset_tracks()
    canvas.size = Math.min(window.innerWidth, window.innerHeight)
    const vertical = window.innerWidth > window.innerHeight
    if (editor.hasFocus()) {
        canvas.size /= vertical ? 2 : 4
    }
    document.body.className = vertical ? "vertical" : "horizontal"
    canvas.width = canvas.size
    canvas.height = canvas.size
    canvas.radius0 = canvas.size * 0.10
}

function on_editor_change(editor) {
    const text = editor.getValue()
    rings = parse_rhythm(text)
    window.localStorage.setItem("text", text)
}


class Track {
    constructor(start_x, start_y, ts) {
        this.points = [{ x: start_x, y: start_y, ts: ts }]
    }
    get start() {
        return this.points[0]
    }
    get end() {
        return this.points[this.points.length - 1]
    }
    add_point(x, y, ts) {
        this.points.push({ x: x, y: y, ts: ts })
        if (!("drag" in this)) {
            if (Math.abs(y - this.start.y) > 20) {
                this.drag = "y"
            } else if (Math.abs(x - this.start.x) > 20) {
                this.drag = "x"
            }
        }
    }
}

var tracks

function on_mousedown(e) {
    e.preventDefault()
    if (editor.hasFocus()) {
        editor.getInputField().blur()
        reset_tracks()
        return
    }
    start_track("m", e.clientX, e.clientY, e.timeStamp)
}

function diff_period(x1, x2, period) {
    const d = (x2 - x1) % period
    if (d < -0.5 * period) {
        return d + period
    } else if (d > 0.5 * period) {
        return d - period
    } else {
        return d
    }
}

function on_mousemove(e) {
    e.preventDefault()
    update_track("m", e.clientX, e.clientY, e.timeStamp)
}

function on_mouseup(e) {
    e.preventDefault()
    end_tracks()
}


function start_track(id, x, y, ts) {
    tracks[id] = new Track(x - canvas.getBoundingClientRect().left, y - canvas.getBoundingClientRect().top, ts)
}

function update_track(id, x, y, ts) {
    if (id in tracks) {
        tracks[id].add_point(x, y, ts)
    }
}

function reset_tracks() {
    tracks = {}
}

function end_tracks() {
    let touch_ids = Object.keys(tracks)
    if (touch_ids.length == 1) {
        let track = tracks[touch_ids[0]]
        const x = track.start.x - canvas.width / 2
        const y = track.start.y - canvas.height / 2
        const r = Math.sqrt(x * x + y * y)

        if (r < canvas.radius0) {
            if ("drag" in track) {
                if(track.drag == "y") {
                    update_freq(clamp((freq.value - (track.end.y - track.start.y) * canvas.size * 0.00002).toFixed(1), 1, 20))
                }
            } else {
                    toggle_play()
            }
        } else {
            const period = rings[0].period
            const radii_count = rings.reduce((count, ring) => count + Math.ceil(ring.period / period), 0)
            const radius_delta = canvas.size * 0.38 / Math.max(3, radii_count)
            const p = (Math.atan2(y, x) / (2 * Math.PI) + 0.25) * period
            for (const dot of dots(rings, period)) {
                if (in_limits((r - canvas.radius0) / radius_delta - dot.radius_id, 0, 1.0) &&
                    in_limits(diff_period(dot.pulse, p, period), -0.5, 0.5)) {

                    const ring = rings[dot.ring_id]
                    if ("drag" in track) {
                        if (track.drag == "y") {
                            ring.update_volume(clamp((ring.volume.value - (track.end.y - track.start.y) * canvas.size * 0.00002).toFixed(1), 0.0, 2.0))
                        }
                    } else {
                        dot.orig.update_symbol(ring.instrument.next_symbol(dot.symbol))
                    }
                    break
                }
            }
        }
    }
    reset_tracks()
}

function on_touchstart(e) {
    e.preventDefault()
    if (editor.hasFocus()) {
        editor.getInputField().blur()
        reset_tracks()
        return
    }
    for (let t of e.changedTouches) {
        start_track(t.identifier, t.clientX, t.clientY, e.timeStamp)
    }
    if (Object.keys(tracks).length > 1) {
        reset_tracks()
    }
}

function on_touchmove(e) {
    e.preventDefault()
    for (let t of e.changedTouches) {
        update_track(t.identifier, t.clientX - canvas.getBoundingClientRect().left, t.clientY - canvas.getBoundingClientRect().top, e.timeStamp)
    }
}

function on_touchend(e) {
    e.preventDefault()
    end_tracks()
}

function on_touchcancel(e) {
    if(e.cancelable) {
        e.preventDefault()
    }
    reset_tracks()
}

function on_editor_focus() {
    stop()
    resize()
}

function on_editor_blur() {
    resize()
}

window.requestAnimationFrame(process)
window.addEventListener('resize', resize, false)
canvas.addEventListener("mousedown",   on_mousedown)
canvas.addEventListener("mousemove",   on_mousemove)
canvas.addEventListener("mouseup",     on_mouseup)
canvas.addEventListener("touchstart",  on_touchstart)
canvas.addEventListener("touchmove",   on_touchmove)
canvas.addEventListener("touchend",    on_touchend)
canvas.addEventListener("touchcancel", on_touchcancel)
document.addEventListener('DOMContentLoaded', resize)
editor.on("focus", on_editor_focus)
editor.on("blur", on_editor_blur)
editor.on("changes", on_editor_change)

var start_ts = 0
var pulse_counter = 0

</script>
</body>
</html>
