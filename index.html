<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.1.2/howler.core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.48.4/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.48.4/addon/scroll/simplescrollbars.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.1.0/chroma.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.48.4/codemirror.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.48.4/addon/scroll/simplescrollbars.min.css" />
<style>
* {
    margin: 0;
    padding: 0;
}
html, body {
    margin: 0;
    width: 100%;
    height: 100%;
    border: 0;
    overflow: hidden;
    display: block;
}
body {
    display: flex;
    align-items: stretch;
}
body.portrate {
    flex-direction: column;
}
body.landscape {
    flex-direction: row;
}
h1 {
    font-family: sans-serif;
    margin: 4px 16px;
}
:root {
    --header-height: 24px;
    --footer-height: 48px;
}
.portrate footer {
    max-height: var(--footer-height);
    min-height: var(--footer-height);
}
.portrate header {
    max-height: var(--header-height);
    min-height: var(--header-height);
}
:root {
    --header-width: 24px;
    --footer-width: 48px;
}
.landscape footer {
    max-width: var(--footer-width);
    min-width: var(--footer-width);
    min-height: 100%;
    max-height: 100%;
}
.landscape header {
    max-width: var(--header-width);
    min-width: var(--header-width);
    min-height: 100%;
    max-height: 100%;
}

main {
    display: none;
    flex-grow: 1;
    overflow: auto;
}
main:target {
    display: block;
}
footer nav {
    display: flex;
    justify-content: space-evenly;
    align-items: center;
}
.landscape footer nav {
    flex-direction: column;
    height: 100%;
}
nav a{
    display: block;
    padding: 4px;
}
.svg-icon {
  width: 2em;
  height: 2em;
}
.svg-icon path,
.svg-icon polygon,
.svg-icon rect {
  fill: #4691f6;
}

.svg-icon circle {
  stroke: #4691f6;
  stroke-width: 1;
}
#editor {
    flex-grow: 1;
    align-self: stretch;
}
.CodeMirror {
    font-size: 20px;
}

.CodeMirror {
    min-height: 100%;
    max-height: 100%;
    min-width: 100%;
    max-width: 100%;
}

.cm-s-default .cm-keyword     { color: blue; }
.cm-s-default .cm-punctuation { color: red;  }
.cm-s-default .cm-comment     { color: #488; }
.cm-s-default .cm-parameter   { color: #a1a; }

#settings form {
    display: grid;
    grid-template-columns: 70% 30%;
    grid-gap: 4px;
    margin: 8px;
}
#settings form label {
    font-family: monospace;
    grid-column: 1 / 2;
}
#settings form input {
    font-family: monospace;
    grid-column: 2 / 3;
}
#catalog ul {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    padding: 16px 36px;
    list-style-type: none;
}
#catalog li {
    text-align: center;
    font-family: sans-serif;
    font-size: 2em;
    margin-bottom: 0.5em;
    background-color: #dee6ff;
    padding: 0.1em 0;
}
a.switch {
    text-decoration: none;
}
a.switch,
a.switch:visited,
a.switch:active,
a.switch:hover,
a.switch:focus {
    color: black
}
a.switch:hover {
    cursor: pointer;
}
</style>
</head>
<body>

<header></header>

<main id="catalog">
    <h1>Catalog</h1>
    <ul></ul>
</main>

<main id="play" class="active">
    <canvas id="canvas"></canvas>
</main>

<main id="code">
    <div id="editor"></div>
</main>

<main id="clone">
  <h1>Clone</h1>
</main>

<main id="settings">
    <h1>Settings</h1>
    <form></form>
</main>

<footer>
    <nav>
        <a href="#catalog">
            <svg class="svg-icon" viewBox="0 0 20 20">
                <path d="M8.627,7.885C8.499,8.388,7.873,8.101,8.13,8.177L4.12,7.143c-0.218-0.057-0.351-0.28-0.293-0.498c0.057-0.218,0.279-0.351,0.497-0.294l4.011,1.037C8.552,7.444,8.685,7.667,8.627,7.885 M8.334,10.123L4.323,9.086C4.105,9.031,3.883,9.162,3.826,9.38C3.769,9.598,3.901,9.82,4.12,9.877l4.01,1.037c-0.262-0.062,0.373,0.192,0.497-0.294C8.685,10.401,8.552,10.18,8.334,10.123 M7.131,12.507L4.323,11.78c-0.218-0.057-0.44,0.076-0.497,0.295c-0.057,0.218,0.075,0.439,0.293,0.495l2.809,0.726c-0.265-0.062,0.37,0.193,0.495-0.293C7.48,12.784,7.35,12.562,7.131,12.507M18.159,3.677v10.701c0,0.186-0.126,0.348-0.306,0.393l-7.755,1.948c-0.07,0.016-0.134,0.016-0.204,0l-7.748-1.948c-0.179-0.045-0.306-0.207-0.306-0.393V3.677c0-0.267,0.249-0.461,0.509-0.396l7.646,1.921l7.654-1.921C17.91,3.216,18.159,3.41,18.159,3.677 M9.589,5.939L2.656,4.203v9.857l6.933,1.737V5.939z M17.344,4.203l-6.939,1.736v9.859l6.939-1.737V4.203z M16.168,6.645c-0.058-0.218-0.279-0.351-0.498-0.294l-4.011,1.037c-0.218,0.057-0.351,0.28-0.293,0.498c0.128,0.503,0.755,0.216,0.498,0.292l4.009-1.034C16.092,7.085,16.225,6.863,16.168,6.645 M16.168,9.38c-0.058-0.218-0.279-0.349-0.498-0.294l-4.011,1.036c-0.218,0.057-0.351,0.279-0.293,0.498c0.124,0.486,0.759,0.232,0.498,0.294l4.009-1.037C16.092,9.82,16.225,9.598,16.168,9.38 M14.963,12.385c-0.055-0.219-0.276-0.35-0.495-0.294l-2.809,0.726c-0.218,0.056-0.351,0.279-0.293,0.496c0.127,0.506,0.755,0.218,0.498,0.293l2.807-0.723C14.89,12.825,15.021,12.603,14.963,12.385"></path>
            </svg>
        </a>
        <a href="#play">
            <svg class="svg-icon" viewBox="0 0 20 20">
                <path d="M16.899,3.05c-0.085-0.068-0.192-0.095-0.299-0.074L7.947,4.779c-0.17,0.034-0.291,0.182-0.291,0.353v7.364c-0.494-0.536-1.199-0.873-1.983-0.873c-1.491,0-2.704,1.213-2.704,2.704s1.213,2.704,2.704,2.704c1.491,0,2.705-1.213,2.705-2.704V7.952l7.933-1.659v4.399c-0.494-0.535-1.199-0.873-1.983-0.873c-1.491,0-2.704,1.213-2.704,2.704c0,1.492,1.213,2.705,2.704,2.705c1.49,0,2.704-1.213,2.704-2.705V3.33C17.031,3.221,16.982,3.119,16.899,3.05 M5.673,16.311c-1.094,0-1.983-0.889-1.983-1.983s0.889-1.983,1.983-1.983c1.095,0,1.983,0.889,1.983,1.983S6.768,16.311,5.673,16.311 M14.327,14.508c-1.095,0-1.983-0.889-1.983-1.984c0-1.094,0.889-1.982,1.983-1.982c1.094,0,1.983,0.889,1.983,1.982C16.311,13.619,15.421,14.508,14.327,14.508 M16.311,5.558L8.377,7.217V5.428l7.933-1.659V5.558z"></path>
            </svg>
        </a>
        <a href="#code">
                <svg class="svg-icon" viewBox="0 0 20 20">
                    <path d="M18.303,4.742l-1.454-1.455c-0.171-0.171-0.475-0.171-0.646,0l-3.061,3.064H2.019c-0.251,0-0.457,0.205-0.457,0.456v9.578c0,0.251,0.206,0.456,0.457,0.456h13.683c0.252,0,0.457-0.205,0.457-0.456V7.533l2.144-2.146C18.481,5.208,18.483,4.917,18.303,4.742 M15.258,15.929H2.476V7.263h9.754L9.695,9.792c-0.057,0.057-0.101,0.13-0.119,0.212L9.18,11.36h-3.98c-0.251,0-0.457,0.205-0.457,0.456c0,0.253,0.205,0.456,0.457,0.456h4.336c0.023,0,0.899,0.02,1.498-0.127c0.312-0.077,0.55-0.137,0.55-0.137c0.08-0.018,0.155-0.059,0.212-0.118l3.463-3.443V15.929z M11.241,11.156l-1.078,0.267l0.267-1.076l6.097-6.091l0.808,0.808L11.241,11.156z"></path>
                </svg>
        </a>
        <a href="#clone">
            <svg class="svg-icon" viewBox="0 0 20 20">
                <path d="M17.391,2.406H7.266c-0.232,0-0.422,0.19-0.422,0.422v3.797H3.047c-0.232,0-0.422,0.19-0.422,0.422v10.125c0,0.232,0.19,0.422,0.422,0.422h10.125c0.231,0,0.422-0.189,0.422-0.422v-3.797h3.797c0.232,0,0.422-0.19,0.422-0.422V2.828C17.812,2.596,17.623,2.406,17.391,2.406 M12.749,16.75h-9.28V7.469h3.375v5.484c0,0.231,0.19,0.422,0.422,0.422h5.483V16.75zM16.969,12.531H7.688V3.25h9.281V12.531z"></path>
            </svg>
        </a>
        <a href="#settings">
            <svg class="svg-icon" viewBox="0 0 20 20">
                <path d="M17.498,11.697c-0.453-0.453-0.704-1.055-0.704-1.697c0-0.642,0.251-1.244,0.704-1.697c0.069-0.071,0.15-0.141,0.257-0.22c0.127-0.097,0.181-0.262,0.137-0.417c-0.164-0.558-0.388-1.093-0.662-1.597c-0.075-0.141-0.231-0.22-0.391-0.199c-0.13,0.02-0.238,0.027-0.336,0.027c-1.325,0-2.401-1.076-2.401-2.4c0-0.099,0.008-0.207,0.027-0.336c0.021-0.158-0.059-0.316-0.199-0.391c-0.503-0.274-1.039-0.498-1.597-0.662c-0.154-0.044-0.32,0.01-0.416,0.137c-0.079,0.106-0.148,0.188-0.22,0.257C11.244,2.956,10.643,3.207,10,3.207c-0.642,0-1.244-0.25-1.697-0.704c-0.071-0.069-0.141-0.15-0.22-0.257C7.987,2.119,7.821,2.065,7.667,2.109C7.109,2.275,6.571,2.497,6.07,2.771C5.929,2.846,5.85,3.004,5.871,3.162c0.02,0.129,0.027,0.237,0.027,0.336c0,1.325-1.076,2.4-2.401,2.4c-0.098,0-0.206-0.007-0.335-0.027C3.001,5.851,2.845,5.929,2.77,6.07C2.496,6.572,2.274,7.109,2.108,7.667c-0.044,0.154,0.01,0.32,0.137,0.417c0.106,0.079,0.187,0.148,0.256,0.22c0.938,0.936,0.938,2.458,0,3.394c-0.069,0.072-0.15,0.141-0.256,0.221c-0.127,0.096-0.181,0.262-0.137,0.416c0.166,0.557,0.388,1.096,0.662,1.596c0.075,0.143,0.231,0.221,0.392,0.199c0.129-0.02,0.237-0.027,0.335-0.027c1.325,0,2.401,1.076,2.401,2.402c0,0.098-0.007,0.205-0.027,0.334C5.85,16.996,5.929,17.154,6.07,17.23c0.501,0.273,1.04,0.496,1.597,0.66c0.154,0.047,0.32-0.008,0.417-0.137c0.079-0.105,0.148-0.186,0.22-0.256c0.454-0.453,1.055-0.703,1.697-0.703c0.643,0,1.244,0.25,1.697,0.703c0.071,0.07,0.141,0.15,0.22,0.256c0.073,0.098,0.188,0.152,0.307,0.152c0.036,0,0.073-0.004,0.109-0.016c0.558-0.164,1.096-0.387,1.597-0.66c0.141-0.076,0.22-0.234,0.199-0.393c-0.02-0.129-0.027-0.236-0.027-0.334c0-1.326,1.076-2.402,2.401-2.402c0.098,0,0.206,0.008,0.336,0.027c0.159,0.021,0.315-0.057,0.391-0.199c0.274-0.5,0.496-1.039,0.662-1.596c0.044-0.154-0.01-0.32-0.137-0.416C17.648,11.838,17.567,11.77,17.498,11.697 M16.671,13.334c-0.059-0.002-0.114-0.002-0.168-0.002c-1.749,0-3.173,1.422-3.173,3.172c0,0.053,0.002,0.109,0.004,0.166c-0.312,0.158-0.64,0.295-0.976,0.406c-0.039-0.045-0.077-0.086-0.115-0.123c-0.601-0.6-1.396-0.93-2.243-0.93s-1.643,0.33-2.243,0.93c-0.039,0.037-0.077,0.078-0.116,0.123c-0.336-0.111-0.664-0.248-0.976-0.406c0.002-0.057,0.004-0.113,0.004-0.166c0-1.75-1.423-3.172-3.172-3.172c-0.054,0-0.11,0-0.168,0.002c-0.158-0.312-0.293-0.639-0.405-0.975c0.044-0.039,0.085-0.078,0.124-0.115c1.236-1.236,1.236-3.25,0-4.486C3.009,7.719,2.969,7.68,2.924,7.642c0.112-0.336,0.247-0.664,0.405-0.976C3.387,6.668,3.443,6.67,3.497,6.67c1.75,0,3.172-1.423,3.172-3.172c0-0.054-0.002-0.11-0.004-0.168c0.312-0.158,0.64-0.293,0.976-0.405C7.68,2.969,7.719,3.01,7.757,3.048c0.6,0.6,1.396,0.93,2.243,0.93s1.643-0.33,2.243-0.93c0.038-0.039,0.076-0.079,0.115-0.123c0.336,0.112,0.663,0.247,0.976,0.405c-0.002,0.058-0.004,0.114-0.004,0.168c0,1.749,1.424,3.172,3.173,3.172c0.054,0,0.109-0.002,0.168-0.004c0.158,0.312,0.293,0.64,0.405,0.976c-0.045,0.038-0.086,0.077-0.124,0.116c-0.6,0.6-0.93,1.396-0.93,2.242c0,0.847,0.33,1.645,0.93,2.244c0.038,0.037,0.079,0.076,0.124,0.115C16.964,12.695,16.829,13.021,16.671,13.334 M10,5.417c-2.528,0-4.584,2.056-4.584,4.583c0,2.529,2.056,4.584,4.584,4.584s4.584-2.055,4.584-4.584C14.584,7.472,12.528,5.417,10,5.417 M10,13.812c-2.102,0-3.812-1.709-3.812-3.812c0-2.102,1.71-3.812,3.812-3.812c2.102,0,3.812,1.71,3.812,3.812C13.812,12.104,12.102,13.812,10,13.812"></path>
            </svg>
        </a>
    </nav>
</footer>
<script>

"use strict";

const VERSION = "v0.0.3"


var canvas = document.getElementById("canvas")

/***/
if (localStorage.getItem("version") != VERSION) {
    localStorage.clear()
    localStorage.setItem("version", VERSION)
}
/***/

class Settings {
    constructor(version, params) {
        this.version = version
        this.params = params
        for (const param of this.params) {
            this.set(param.name, param.value)
        }
    }

    load(text) {
        const stored = JSON.parse(text)
        if (!stored || !("version" in stored)) {
            return
        }
        for (const [name, value] of stored.entries) {
            this.set(name, value, { existing: true })
        }
    }

    store() {
        return JSON.stringify({
            version: this.version,
            entries: this.params.map(param => [param.name, this.get(param.name)])
        })
    }

    set (path, value, opts) {
        opts = { ...opts }
        const keys = path.split('.')
        let obj = this
        for(let i = 0; i < keys.length; i++) {
            if (!(keys[i] in obj)) {
                if (opts.existing) {
                    return
                }
                if (i != keys.length - 1) {
                    obj[keys[i]] = {}
                }
            }
            if (i == keys.length - 1) {
                obj[keys[i]] = value
            } else {
                obj = obj[keys[i]]
            }
        }
    }

    get (path, not_found) {
        const keys = path.split('.')
        let obj = this
        for(let i = 0; i < keys.length; i++) {
            if (!(keys[i] in obj)) {
                return not_found
            }
            if (i == keys.length - 1) {
                return obj[keys[i]]
            } else {
                obj = obj[keys[i]]
            }
        }
    }

}

class Param {
    constructor(name, value) {
        this.name = name
        this.value = value
    }
}

const settings = new Settings (VERSION, [

    new Param("background_color", "white"),
    new Param("low_vol_color", "#eee"),
    new Param("muted_color", "#ddd"),
    new Param("dot_color", "#444"),
    new Param("dot_dim_color", "#888"),

    new Param("header_height", 40),
    new Param("footer_height", 48),
    new Param("start_shift", 10),

    new Param("landscape.header_width", 24),
    new Param("landscape.footer_width", 48),

    new Param("default_freq", 7.0),

    new Param("volume_mix.factor", 0.3),
    new Param("volume_mix.shift", 0.2),
    new Param("min_radius_devider", 4),
    new Param("play_range.draw.0", -0.1),
    new Param("play_range.draw.1", 0.9),
    new Param("play_range.sound.0", -0.1),
    new Param("play_range.sound.1", 0.3),
    new Param("play_range.prev_round", 0.5),

    new Param("main.size", 0.95),
    new Param("main.radius0", 0.1),

    new Param("thumbnail.height", 0.2),
    new Param("thumbnail.width", 0.2),
    new Param("thumbnail.size", 0.17),
    new Param("thumbnail.style", "simple"),
    new Param("thumbnail.radius0", 0.3),
    new Param("thumbnail.shadow", ""),

    new Param("instrument.height", 0.2),
    new Param("instrument.width", 0.2),
    new Param("instrument.size", 0.17),
    new Param("instrument.radius0", 0.3),
    new Param("instrument.shadow", ""),


    new Param("landscape.thumbnail.height", 0.2),
    new Param("landscape.thumbnail.width", 0.2),
    new Param("landscape.thumbnail.size", 0.17),
    new Param("landscape.instrument.height", 0.2),
    new Param("landscape.instrument.width", 0.2),
    new Param("landscape.instrument.size", 0.17),

])

settings.load(localStorage.getItem("settings"))

var form = document.querySelector("#settings form")
form.addEventListener("change", on_form_change)

function on_form_change(e) {
    console.log(`setting ${e.target.name}="${e.target.value}"`)
    settings.set(e.target.name, e.target.value)
    update_css()
    localStorage.setItem("settings", settings.store())
}



for (let param of settings.params) {
    let label = document.createElement("label")
    label.for = param.name
    label.append(param.name)
    let input = document.createElement("input")
    input.name = param.name
    input.value = settings.get(param.name)
    form.append(label, input)
}

class Dot {
    constructor(pulse, symbol) {
        this.pulse = pulse
        this.symbol = symbol
        this.played_pulse = null
    }
    get active() {
        return this.symbol.value != '.'
    }

    update_symbol(symbol) {
        editor.setValue(this.symbol.calc_text(symbol))
    }
}

class Ring {
    constructor(name, instrument, symbols, opts) {
        this.name = name
        this.instrument = instrument
        opts = Object.assign({ volume: { value: 1.0 } }, opts);
        this.volume = opts.volume
        this.dots = []
        let pulse = 0
        for (const symbol of symbols) {
            this.dots.push(new Dot(pulse, symbol))
            pulse++
        }
        this.period = this.dots.length
    }

    update_volume(volume) {
        if ("text" in this.volume) {
            editor.setValue(this.volume.calc_text(volume))
        } else {
            editor.setValue(Parsed.insert(this.name.text, this.name.pos + this.name.length, " v" + volume))
        }
    }

    update_name(name) {
        editor.setValue(this.name.calc_text(name))
    }
}

class Sound extends Howl {
    constructor(src, volume_factor) {
        super({ src })
        this.volume_factor = volume_factor === undefined ? 1.0 : volume_factor
        this.volume_factor *= 0.5
    }
    play(volume) {
        super.volume(volume * this.volume_factor)
        super.play()
    }
}

class Instrument {
    constructor(sound, color) {
        this.sound = sound
        this.color = color
        if (this.sound instanceof Sound) {
            this.symbols = ["x"]
        } else {
            this.symbols = Object.keys(this.sound)
        }
    }

    play(symbol, volume) {
        let sound = this.sound instanceof Sound ? this.sound : this.sound[symbol]
        sound.play(volume)
    }

    next_symbol(symbol) {
        const symbol_id = this.symbols.indexOf(symbol)
        return symbol_id == this.symbols.length - 1 ? "." : this.symbols[symbol_id + 1]
    }
}

class Parsed {
    constructor(text, pos, length, value) {
        this.text = text
        this.pos = pos
        this.length = length
        this.value = value
    }

    calc_text(new_value) {
        return this.text.slice(0, this.pos) + new_value + this.text.slice(this.pos + this.length)
    }

    static insert(text, pos, what) {
        return text.slice(0, pos) + what + text.slice(pos)
    }
}

class Circle {
    constructor(name, rings, opts) {
        this.name = name
        this.rings = rings
        opts = Object.assign({ repeats: { value: 0 } }, opts)
        this.repeats = opts.repeats
        
        this.dots = []
        let radius_id = 0
        for (const [ring_id, ring] of this.rings.entries()) {
            const part_count = Math.ceil(ring.period / this.period)
            for (let part = 0; part < part_count; part++) {
                for (let iteration = 0; iteration < Math.ceil(this.period / ring.period); iteration++) {
                    for (let dot of ring.dots) {
                        const iteration_dot_pulse = dot.pulse + iteration * ring.period
                        if (!in_limits(iteration_dot_pulse - part * this.period, 0, this.period)) {
                            continue
                        }
                        this.dots.push({ volume: ring.volume.value, ring_id, period: part_count * this.period, part_id: part, radius_id, symbol: dot.symbol.value, pulse: iteration_dot_pulse, active: dot.active, orig: dot, color: ring.instrument.color })
                    }
                }
                radius_id++;
            }
        }
        this.radii_count = radius_id
    }

    update_name(name) {
        if ("text" in this.name) {
            editor.setValue(this.name.calc_text(name))
        } else {
            editor.setValue(Parsed.insert(this.rings[0].name.text, this.rings[0].name.pos, name + ".\n"))
        }
    }

    get period() {
        return this.rings[0].period
    }
    
    get max_period() {
        return Math.max(...this.rings.map(r => Math.ceil(r.period / this.period) * this.period))
    }
    
    get duration() {
        if (this.repeats.value) {
            return this.max_period * this.repeats.value
        } else {
            return Infinity
        }
    }
    
    reset_played() {
        for (let ring of this.rings) {
            for (let dot of ring.dots) {
                dot.played_pulse = null
            }
        }
    }
    
    update(now, elapsed, pulse) {
    
        /***
        let played = false
        let report = now.toFixed(2).padEnd(16, ' ') + elapsed.toFixed(2).padEnd(8, ' ') + pulse.toFixed(2).padStart(8, ' ') + "  " + (this.name.value + "." + Math.floor(pulse/this.max_period)).padEnd(5, ' ')
        /***/

        for (let ring of this.rings) {
            let ring_reported = false
            for (let dot of ring.dots) {
                if (ring.volume.value > 0 && dot.active
                    && in_limits((pulse - dot.pulse) % ring.period, settings.play_range.sound[0], settings.play_range.sound[1])
                    && (dot.played_pulse ==  null || pulse - dot.played_pulse > ring.period - settings.play_range.prev_round)) {

                    /***
                    played = true
                    ring_reported = true
                    const ring_report = `${ring.name.value}-${dot.pulse}:`.padEnd(12, ' ') + `${((pulse - dot.pulse) % ring.period).toFixed(2)}`.padStart(5, ' ') + "[" + `${(dot.played_pulse ==  null ? "---" : (pulse - dot.played_pulse - ring.period).toFixed(2))}`.padStart(5, ' ') + "]"
                    report += ring_report.padEnd(28, ' ')
                    /***/

                    ring.instrument.play(dot.symbol.value, ring.volume.value)
                    dot.played_pulse = pulse
                }
            }

            /***
            if (!ring_reported) {
                report += "".padEnd(28, ' ')
            }
            /***/
        }

        /***
        if (played) {
            console.log(report)
        }
        /***/
    }
    
    draw (ctx, x, y, size, pulse, label, opts) {
        opts = { style: "full", ...opts }
        if (!("shadow" in opts) || opts.shadow != null) {
            Circle.draw_shadow(ctx, x, y, size, opts.shadow)
        } else {
            ctx.beginPath()
            ctx.arc(x, y, size * 0.5, 0, 2 * Math.PI)
            ctx.fillStyle = settings.background_color
            ctx.fill()
        }
        if (opts.style == "full") {
            this.draw_dots(ctx, x, y, size, pulse, opts)
        } else if (opts.style == "simple") {
            this.draw_simple(ctx, x, y, size, pulse, opts)
        } else {
            if (pulse !== true) {
                opts.label = { ...opts.label, dim: true }
            }
        }
        Circle.draw_label(ctx, x, y, size * opts.radius0_ratio, label, opts.label)
    }

    static draw_shadow (ctx, x, y, size, opts) {
        opts = { color: '#532', blur: 5, offset_y: 0.05, size: 1.0, ...opts }
        ctx.save()
        ctx.shadowColor = opts.color
        ctx.shadowBlur = opts.blur
        ctx.shadowOffsetY = size * opts.offset_y
        ctx.beginPath()
        ctx.arc(x, y, size * opts.size * 0.5, 0, 2 * Math.PI)
        ctx.fillStyle = settings.background_color
        ctx.fill()
        ctx.restore()
    }

    draw_dots (ctx, x, y, size, pulse, opts) {
        opts = { dot: 0.012, dot_line: 0.012, sep_line: 0.006, radii_line: 0.006, ...opts }
        const angle_delta = 2.0 * Math.PI / this.period
        const radius0 = size * opts.radius0_ratio
        const dot_size = size * opts.dot
        const radius_delta = (size * 0.5 - radius0) / Math.max(opts.min_radius_devider, this.radii_count)
        const radius1 = radius0 + this.radii_count * radius_delta

     
        ctx.save()
        ctx.translate(x, y)

        for (const dot of this.dots) {
            ctx.save()

            ctx.rotate((-0.5 + 2 * dot.pulse / this.period) * Math.PI)

            const radius = radius0 + radius_delta * (dot.radius_id + 0.5)
            const playing = pulse === true || pulse !== true && pulse !== false && dot.active && (checkpoint.ts || checkpoint.pulse) && in_limits((pulse - dot.pulse) % dot.period, settings.play_range.draw[0], settings.play_range.draw[1])

            ctx.beginPath()
            ctx.arc(0, 0, radius + 0.5 * radius_delta, + angle_delta / 2, - angle_delta / 2, true)
            ctx.arc(0, 0, radius - 0.5 * radius_delta, - angle_delta / 2, + angle_delta / 2, false)
            ctx.closePath()
            if (dot.volume > 0) {
                ctx.fillStyle = playing ? chroma(dot.color).darken().saturate() : chroma.mix(settings.low_vol_color, dot.color, settings.volume_mix.factor * dot.volume + settings.volume_mix.shift)
            } else {
                ctx.fillStyle = settings.muted_color
            }
            ctx.fill()

            if (dot.active) {
                ctx.save()
                ctx.translate(radius, 0)
                ctx.beginPath()
                if (dot.symbol == 's' || dot.symbol == 'h') {
                    ctx.moveTo(0 - dot_size, 0 - dot_size)
                    ctx.lineTo(0 - dot_size, 0 + dot_size)
                    ctx.lineTo(0 + dot_size, 0)
                } else if (dot.symbol == 'c') {
                    ctx.moveTo(0 - dot_size, 0 - dot_size)
                    ctx.lineTo(0 - dot_size, 0 + dot_size)
                    ctx.lineTo(0 + dot_size, 0 + dot_size)
                    ctx.lineTo(0 + dot_size, 0 - dot_size)
                } else if (dot.symbol == 'k') {
                    ctx.moveTo(0 - dot_size, 0 - dot_size / 2)
                    ctx.lineTo(0 - dot_size, 0 + dot_size / 2)
                    ctx.lineTo(0 + dot_size, 0 + dot_size / 2)
                    ctx.lineTo(0 + dot_size, 0 - dot_size / 2)
                } else if (dot.symbol == 'd' || dot.symbol == 'b') {
                    ctx.moveTo(0 - dot_size, 0 - dot_size / 2)
                    ctx.lineTo(0 - dot_size, 0 + dot_size / 2)
                    ctx.lineTo(0 + dot_size, 0 + dot_size)
                    ctx.lineTo(0 + dot_size, 0 - dot_size)
                } else {
                    ctx.arc(0, 0, dot_size, 0, 2 * Math.PI)
                }
                ctx.closePath()
                if (opts.dot_line) {
                    ctx.lineWidth = size * opts.dot_line
                    ctx.strokeStyle = settings.background_color
                    ctx.stroke()
                }
                ctx.fillStyle = dot.volume > 0 ? settings.dot_color : settings.dot_dim_color
                ctx.fill()
                ctx.restore()
            }

            ctx.restore()
        }

        ctx.strokeStyle = settings.background_color
        ctx.lineWidth = size * opts.radii_line

        for (let i = 0; i < this.period; i++) {
            ctx.save()
            ctx.rotate(2 * Math.PI * (i - 0.5) / this.period)
            ctx.beginPath()
            ctx.moveTo(radius0, 0)
            ctx.lineTo(radius1, 0)
            ctx.stroke()
            ctx.restore()
        }

        ctx.lineWidth = size * opts.sep_line
        for (let i = 0; i < this.radii_count + 1; i++) {
            ctx.beginPath()
            ctx.arc(0, 0, radius0 + i * radius_delta, 0, 2 * Math.PI)
            ctx.stroke()
        }

        ctx.restore()
    }

    static draw_label (ctx, x, y, size, label, opts) {
        opts = { color: "#469", font: 2, outline: 0.1, ...opts }
        if (opts.dim) {
            opts.color = chroma.mix(settings.low_vol_color, opts.color, settings.volume_mix.factor + settings.volume_mix.shift)
        }
        ctx.save()
        ctx.translate(x, y)

        if (label) {
            ctx.textAlign = "center"
            ctx.textBaseline = "middle"
            ctx.font = 'bold '+ Math.floor(size * opts.font) + 'px sans-serif'
            ctx.fillStyle  = opts.color
            ctx.strokeStyle = settings.background_color
            ctx.lineWidth = size * opts.outline * 2
            ctx.strokeText(label, 0, size * opts.font * 0.1)
            ctx.fillText(label, 0, size * 0.15)
        } else {
            const shape_size = size * 0.4
            ctx.beginPath()
            if (checkpoint.ts) {
                ctx.moveTo(0 - shape_size, 0 - shape_size)
                ctx.lineTo(0 - shape_size, 0 + shape_size)
                ctx.lineTo(0 + shape_size, 0 + shape_size)
                ctx.lineTo(0 + shape_size, 0 - shape_size)
            } else {
                ctx.moveTo(0 - 0.7 * shape_size, 0 - 1.2 * shape_size)
                ctx.lineTo(0 - 0.7 * shape_size, 0 + 1.2 * shape_size)
                ctx.lineTo(0 + 1.3 * shape_size, 0)
            }
            ctx.closePath()
            ctx.lineJoin = "round"
            ctx.lineWidth = size * 0.15
            ctx.strokeStyle = "#469"
            ctx.stroke()
        }

        ctx.restore()
    }

    draw_simple (ctx, x, y, size, pulse, opts) {
        opts = { sep_line: 0.006, ...opts }
        const radius0 = size * opts.radius0_ratio
        const radius_delta = (size * 0.5 - radius0) / Math.max(opts.min_radius_devider, this.radii_count)

        ctx.lineWidth = radius_delta - size * opts.sep_line
        const seen_radius = {}
        for (const dot of this.dots) {
            if (seen_radius[dot.radius_id]) {
                continue
            }
            seen_radius[dot.radius_id] = true

            ctx.strokeStyle = pulse === true ? chroma(dot.color).darken().saturate() : chroma.mix(settings.low_vol_color, dot.color, settings.volume_mix.factor + settings.volume_mix.shift)

            ctx.beginPath()
            ctx.arc(x, y, radius0 + (dot.radius_id + 0.5) * radius_delta, 0, 2 * Math.PI)
            ctx.stroke()
        }
    }

    draw_debug(ctx, center_x, center_y, size, track, opts) {
        opts = { line: 0.002, color: "red", ...(opts || {}) }
        const angle_delta = 2.0 * Math.PI / this.period
        const radius0 = size * opts.radius0_ratio
        const radius_delta = (size * 0.5 - radius0) / Math.max(opts.min_radius_devider, this.radii_count)

        const x = track.start.x - center_x
        const y = track.start.y - center_y
        const r = Math.sqrt(x * x + y * y)
        const p = (Math.atan2(y, x) / (2 * Math.PI) + 0.25) * this.period

        ctx.save()
        ctx.translate(center_x, center_y)
        ctx.strokeStyle = opts.color
        ctx.lineWidth = size * opts.line
        if (r < radius0) {
            ctx.beginPath()
            ctx.arc(0, 0, radius0, 0, 2 * Math.PI)
            ctx.stroke()
        } else if (r <= size * 0.5) {

            for (const dot of this.dots) {
                if (in_limits((r - radius0) / radius_delta - dot.radius_id, 0, 1.0) &&
                    in_limits(diff_period(dot.pulse, p, this.period), -0.5, 0.5)) {

                    const radius = radius0 + radius_delta * dot.radius_id

                    ctx.save()
                    ctx.rotate((-0.5 + 2 * dot.pulse / this.period) * Math.PI)
                    ctx.beginPath()
                    ctx.arc(0, 0, radius + radius_delta, + angle_delta / 2, - angle_delta / 2, true)
                    ctx.arc(0, 0, radius               , - angle_delta / 2, + angle_delta / 2, false)
                    ctx.closePath()
                    ctx.stroke()
                    ctx.restore()
                }
            }
        }
        ctx.restore()
    }
}

var palette = [
"#1f77b4",
"#ff7f0e",
"#2ca02c",
"#d62728",
"#9467bd",
"#8c564b",
"#17becf",
"#e377c2",
"#b4b518",
]

var sounds = {
    'beat':             new Sound('beat-wood.mp3', 0.4),
    'beat_high':        new Sound('beat-wood-high.mp3', 0.15),
    'clap':             new Sound('clap.mp3'),
    'shake':            new Sound('shake.mp3', 0.2),
    'dundunba':         new Sound('dundunba.mp3', 0.25),
    'sangban':          new Sound('sangban.mp3', 0.2),
    'sangban_closed':   new Sound('sangban-closed.mp3', 0.2),
    'kenkeni':          new Sound('kenkeni.mp3', 0.2),
    'djembe_slap':      new Sound('djembe-slap.mp3'),
    'djembe_tone':      new Sound('djembe-tone.mp3'),
    'djembe_base':      new Sound('djembe-base.mp3', 0.6),
}


var instruments = {
    'clave':       new Instrument({ x: sounds.beat, h: sounds.beat_high }, palette[0]),
    'shekere':     new Instrument(sounds.shake, palette[6]),
    'sangban':     new Instrument({ x: sounds.sangban, c: sounds.sangban_closed }, palette[1]),
    'dundunba':    new Instrument(sounds.dundunba, palette[3]),
    'kenkeni':     new Instrument(sounds.kenkeni, palette[4]),
    'bass':        new Instrument({ s: sounds.sangban, c: sounds.sangban_closed, d: sounds.dundunba, k: sounds.kenkeni }, palette[5]),
    'djembe':      new Instrument({ s: sounds.djembe_slap, t: sounds.djembe_tone, b: sounds.djembe_base }, palette[2])
}

function split_tokens(text, sep_re) {
    const splits = text.split(sep_re)
    const res = []
    for (let i = 0, pos = 0, index = 0; i < splits.length; i += 2) {
        const content = splits[i]
        const sep = i + 1 < splits.length ? splits[i + 1] : ""
        res.push({ text, index, pos, content, sep })
        pos += content.length + sep.length
        index++
    }
    return res
}

function split_lines(text) {
    return split_tokens(text, /(\r?\n)/)
}

function split_words(text) {
    return split_tokens(text, /(\s+)/)
}

function split_chars(text) {
    let pos = 0
    const res = []
    for(const content of text.split("")) {
        res.push({ text, index: pos, pos, content, sep: "" })
        pos++
    }
    return res
}

class Rhythm {
    constructor(name, text) {
        this.name = name
        this.parse(text)
    }

    parse (text) {
        this.text = text
        this.circles = []
        let rings = []
        let symbols = []
        let circle_name = null
        let ring_name = null
        let circle_opts = {}
        let ring_opts = {}

        function valid_circle(name, rings) {
            return name && name.length && rings.length
        }

        function valid_ring(name, symbols) {
            return name && name.value in instruments && symbols.length
        }

        function to_symbols(pos, pattern) {
            let symbols = []
            for (let c of split_chars(pattern)) {
                if (!/\s+/.test(c.content)) {
                    symbols.push(new Parsed(text, pos + c.pos, c.content.length, c.content))
                }
            }
            return symbols
        }

        for (let line of split_lines(text)) {
            const cleaned = line.content.replace(/#.*$/, "")

            let res = cleaned.match(/^(\d+)\.(.*)$/)
            if (res) {
                if (valid_ring(ring_name, symbols)) {
                    rings.push(new Ring(ring_name, instruments[ring_name.value], symbols, ring_opts))
                }
                if (valid_circle(circle_name, rings)) {
                    this.circles.push(new Circle(circle_name, rings, circle_opts))
                }
                circle_name = new Parsed(text, line.pos, res[1].length, res[1])
                symbols = []
                ring_name = null
                ring_opts = {}
                rings = []
                circle_opts = {}

                const opt_pos = line.pos + res[1].length + 1
                for (let token of split_words(res[2])) {
                    let res = token.content.match(/^x(\d+)$/)
                    if (res) {
                        circle_opts.repeats = new Parsed(text, opt_pos + token.pos + 1, res[1].length, parseInt(res[1]))
                        continue
                    }
                }
                continue
            }

            res = cleaned.match(/^([^:\s][^:]*):(.*)$/)
            if (res) {
                if (valid_ring(ring_name, symbols)) {
                    rings.push(new Ring(ring_name, instruments[ring_name.value], symbols, ring_opts))
                }
                const tokens = split_words(res[1])
                ring_name = new Parsed(text, line.pos + tokens[0].pos, tokens[0].content.length, tokens[0].content)
                symbols = to_symbols(line.pos + res[1].length + 1, res[2])
                ring_opts = {}
                for (let token of tokens.slice(1)) {
                    const res = token.content.match(/^v(\d*\.?\d+)$/)
                    if (res) {
                        ring_opts.volume = new Parsed(text, line.pos + token.pos + 1, res[1].length, parseFloat(res[1]))
                    }
                }
                continue
            }

            symbols = symbols.concat(to_symbols(line.pos, cleaned))
        }

        if (valid_ring(ring_name, symbols)) {
            rings.push(new Ring(ring_name, instruments[ring_name.value], symbols, ring_opts))
        }

        if (valid_circle(circle_name, rings)) {
            this.circles.push(new Circle(circle_name, rings, circle_opts))
        } else if (rings.length) {
            this.circles.push(new Circle({ value: "" }, rings))
        }
        
        this.fix_circles()
    }

    fix_circles() {
        if (this.circles.length) {
            for (let circle_id = 0; circle_id < this.circles.length; circle_id++) {
                if (this.circles[circle_id].name.value != circle_id + 1) {
                    this.circles[circle_id].update_name(circle_id + 1)
                }
            }
        } else {
            editor.setValue("1.\nshekere:   x... x... x... x...\n")
        }
    }
}

class Catalog {
    constructor(version, rhythms) {
        this.version = version
        this.rhythms = rhythms
        this.rhythm_id = 0
    }

    get rhythm() {
        return this.rhythms[this.rhythm_id]
    }

    load(text) {
        const stored = JSON.parse(text)
        if (!stored || !("version" in stored)) {
            return
        }
        for (const [name, text] of stored.rhythms) {
            const rhythm = new Rhythm(name, text)
            let index = this.rhythms.findIndex(rhythm => rhythm.name == name)
            if (index == -1) {
                this.rhythms.push(rhythm)
            } else {
                this.rhythms[index] = rhythm
            }
        }
    }
    store() {
        return JSON.stringify({
            version: this.version,
            rhythms: this.rhythms.map(rhythm => [rhythm.name, rhythm.text])
        })
    }

    switch_to(new_rhythm) {
        let index = this.rhythms.findIndex(rhythm => rhythm.name == new_rhythm)
        if (index == -1 || this.rhythm_id == index) {
            return false
        }
        this.rhythm_id = index
        editor.setValue(this.rhythm.text)
        stop()
        checkpoint.circle_id = 0
        return true
    }
}

const catalog = new Catalog(VERSION, [
    new Rhythm("djole", `\
1. x2
shekere:
    x... x... x... x...
2. x4
shekere:
    x... x... x... x...
sangban:
    c... x... c... x...
dundunba:
    x... .... x.x. ....
3. x4
shekere:
    x... x... x... x...
bass:
    d... s... d.d. s...
kenkeni v0.7:
    ..xx ..xx ..xx ..xx
4. x8
shekere:
    x... x... x... x...
bass:
    d... s... d.d. s...
kenkeni v0.5:
    ..xx ..xx ..xx ..xx
djembe:
    tttt b... t.t. b...
5. x4
shekere:
    x... x... x... x...
bass:
    d.kk s.kk d.dk s.kk
djembe:
    ttst tstt stts ttst
    tstt s.ss ttst tss.
`),
    new Rhythm("balakulandjan", `\
1. x2
shekere:
    x... .... x... ....
kenkeni:
    x... x... x... x...
2. x4
shekere:
    x... .... x... ....
sangban:
    .... .... ..x. x...
dundunba:
    x... ..x. x... ..x.
3. x4
shekere:
    x... .... x... ....
kenkeni:
    x... x... x... x...
bass:
    d... ..d. d.s. s.d.
4. x8
shekere:
    x... .... x... ....
kenkeni:
    x... x... x... x...
bass:
    d... ..d. d.s. s.d.
djembe:
    b.tt ..st t.bs .bs.
5. x2
shekere:
    x... .... x... ....
kenkeni:
    x... x... x... x...
bass:
    d... ..d. d.s. s.d.
djembe:
    b.ss .bss b.ss ttss
    b.ss .bss b.s. ttss
6. x2
shekere:
    x... .... x... ....
kenkeni:
    x... x... x... x...
bass:
    d... ..d. d.s. s.d.
djembe:
    ttst tstt s.ts tts.
    ttst tstt s.t. tts.
7. x2
shekere:
    x... .... x... ....
kenkeni:
    x... x... x... x...
bass:
    d... ..d. d.s. s.d.
djembe:
    bsss ttss s... ss..
    bsss ttss s.s. sstt
8. x2
shekere:
    x... .... x... ....
kenkeni:
    x... x... x... x...
bass:
    d... ..d. d.s. s.d.
djembe:
    ..ss .s.t t.s. ss.t
    t.ss .s.t t.s. sstt
`),
])

catalog.load(localStorage.getItem("catalog"))

var rhythm_container = document.querySelector("#catalog ul")
for (const rhythm of catalog.rhythms) {
    let a = document.createElement("a")
    a.href = "#play/" + encodeURIComponent(rhythm.name)
    a.className = "switch"
    a.append(rhythm.name)
    let li = document.createElement("li")
    li.append(a)
    rhythm_container.append(li)
}

CodeMirror.defineMode("rhythm", function() {
    return {
        token: function(stream) {
            if (stream.eatSpace()) {
                return null
            }
            if (stream.match("#")) {
                stream.skipToEnd();
                return "comment";
            }
            for (const word of ["djembe", "dundunba", "dununba", "sangban", "kenkeni", "shekere", "clave", "bass"]) {
                if (stream.match(word, true, true)) {
                    return "keyword"
                }
            }
            if (stream.match(":")) {
                return "punctuation"
            }
            if (stream.match(/[vf]\d*\.?\d+/) || stream.match(/x\d+/)) {
                return "parameter"
            }
            stream.eatWhile(/\S/)
            return null;
        }
    }
})

var editor = CodeMirror(document.getElementById("editor"), { mode: "rhythm", value: catalog.rhythm.text, scrollbarStyle: "overlay" })

class Application {
    constructor(version) {
        this.version = version
        this.freq = settings.default_freq
    }

    load(text) {
        const stored = JSON.parse(text)
        if (!stored || !("version" in stored)) {
            return
        }
        this.freq = stored.freq
    }

    store() {
        return JSON.stringify({
            version: this.version,
            freq: this.freq
        })
    }

    update_freq(freq) {
        if (this.freq == freq) {
            return
        }

        if (checkpoint.ts) {
            checkpoint = processed

            /***/
            console.log(`new freq=${freq} ts=${checkpoint.ts.toFixed(2)} cirlce_id=${checkpoint.circle_id} pulse=${checkpoint.pulse.toFixed(2)}`)
            /***/
        } else {
            /***/
            console.log(`new freq=${freq}`)
            /***/
        }

        this.freq = freq

        localStorage.setItem("app", this.store())
    }
}

const app = new Application(VERSION)
app.load(localStorage.getItem("app"))

function in_limits(x, l1, l2) {
    return x >= l1 && x < l2
}

function clamp(x, min, max) {
    return Math.min(Math.max(x, min), max)
};

function process(ts) {
    let { pulse, circle_id } = checkpoint
    if (checkpoint.ts) {
        const circles = catalog.rhythm.circles
        let elapsed = ts - checkpoint.ts
        pulse += elapsed * app.freq / 1000
        while (pulse >= circles[circle_id].duration) {
            pulse -= circles[circle_id].duration
            circle_id ++
            if (circle_id >= circles.length) {
                circle_id = 0
                circles.forEach(c => c.reset_played())
                console.log(`restarting ts=${ts.toFixed(2)} pulse=${pulse.toFixed(2)}`)
                checkpoint.ts = ts
                checkpoint.pulse = pulse
                checkpoint.circle_id = circle_id
                elapsed = 0
            }
        }
        circles[circle_id].update(ts, elapsed, pulse)
    }

    draw(circle_id, pulse, ts)
    window.requestAnimationFrame(process)
    processed = { ts, circle_id, pulse }
}

function stop() {
    console.log(`stop ts=${checkpoint.ts.toFixed(2)} cirlce_id=${processed.circle_id}`)
    checkpoint.circle_id = processed.circle_id
    checkpoint.ts = 0
    checkpoint.pulse = 0
    catalog.rhythm.circles.forEach(c => {c.reset_played()})
}

function start() {
    checkpoint.ts = performance.now() + settings.start_shift
    console.log(`starting ts=${checkpoint.ts.toFixed(2)}  cirlce_id=${checkpoint.circle_id} pulse=${checkpoint.pulse.toFixed(2)}`)
}

function pause() {
    checkpoint = processed
    console.log(`pause ts=${checkpoint.ts.toFixed(2)} cirlce_id=${checkpoint.circle_id} pulse=${checkpoint.pulse.toFixed(2)}`)
    checkpoint.ts = 0
}

function toggle_play() {
    if (checkpoint.ts) {
        stop()
    } else {
        start()
    }
}

function draw_track(ctx, track, size, now) {
    if (track.points.length) {
        ctx.lineWidth = size * 0.050
        ctx.lineCap = "round"
        let prev_point = track.points[0]
        for (const point of track.points) {
            const life = (point.ts - now + 200) / 200
            if (life > 0) {
                ctx.beginPath()
                ctx.moveTo(prev_point.x, prev_point.y)
                ctx.lineTo(point.x, point.y)
                ctx.strokeStyle = 'rgba(0, 255, 0, ' + life + ')'
                ctx.stroke()
            }
            prev_point = point
        }
    }

    if ("drag" in track) {
        ctx.beginPath()
        ctx.moveTo(track.start.x, track.start.y)
        if (track.drag == "x") {
            ctx.lineTo(track.end.x, track.start.y)
        } else {
            ctx.lineTo(track.start.x, track.end.y)
        }
        ctx.strokeStyle = "blue"
        ctx.lineWidth = canvas.size * 0.020
        ctx.stroke()
    }
}

function draw(circle_id, pulse, now) {

    const circle_opts = { min_radius_devider: settings.min_radius_devider, radius0_ratio: settings.main.radius0 }
    let thumbnail_opts = { ...circle_opts, radius0_ratio: settings.thumbnail.radius0, dot: 0.02, dot_line: 0.04, sep_line: 0.02, style: settings.thumbnail.style }
    if ( settings.thumbnail.shadow == "" ) {
        thumbnail_opts = { ...thumbnail_opts, shadow: null }
    }
    let main_opts = { ...circle_opts, shadow: null }

    const ctx = canvas.getContext('2d')
    ctx.clearRect(0, 0, canvas.width, canvas.height)

    const circles = catalog.rhythm.circles

    if (!circles.length) {
        return
    }

    let thumbnail_delta, thumbnail_dims
    if (canvas.portrate) {
        let delta = settings.thumbnail.width
        if (circles.length > 1) {
            delta = Math.min(delta, (canvas.width / canvas.size - settings.thumbnail.width) / (circles.length - 1))
        }
        thumbnail_delta = [delta, 0]
        thumbnail_dims = settings.thumbnail
    } else {
        let delta = settings.landscape.thumbnail.height
        if (circles.length > 1) {
            delta = Math.min(delta, (canvas.height / canvas.size - settings.landscape.thumbnail.height) / (circles.length - 1))
        }
        thumbnail_delta = [0, delta]
        thumbnail_dims = settings.landscape.thumbnail
    }
    for (let i = 0; i < circles.length; i++) {
        if (i == circle_id) {
            circles[i].draw(ctx, canvas.width / 2, canvas.height / 2, canvas.size * settings.main.size, pulse, null, main_opts)
        }
        circles[i].draw(ctx, canvas.size * (thumbnail_dims.width * 0.5 + i * thumbnail_delta[0]), canvas.size * (thumbnail_dims.height * 0.5 + i * thumbnail_delta[1]), canvas.size * thumbnail_dims.size, i == circle_id, i + 1, thumbnail_opts)
    }

    
    const touch_ids = Object.keys(tracks)

    if (touch_ids.length == 1) {
        const track = tracks[touch_ids[0]]

        for (let i = 0; i < circles.length; i++) {
            if (i == circle_id) {
                circles[i].draw_debug(ctx, canvas.width / 2, canvas.height / 2, canvas.size * settings.main.size, track, circle_opts)
            } else {
                circles[i].draw_debug(ctx, canvas.size * (thumbnail_dims.width * 0.5 + i * thumbnail_delta[0]), canvas.size * (thumbnail_dims.height * 0.5 + i * thumbnail_delta[1]), canvas.size * thumbnail_dims.size, track, { ...circle_opts, radius0_ratio: 0.5, line: 0.02 })
            }
        }

        draw_track(ctx, track, canvas.size, now)

        if ("planned_freq" in track && track.planned_freq.circle_id == circle_id) {
            ctx.font = 'bold 64px sans-serif'
            ctx.fillStyle = "blue"
            ctx.strokeStyle = settings.background_color
            ctx.lineWidth = 5
            let str = "f" + track.planned_freq.value
            ctx.strokeText(str, 8, 72)
            ctx.fillText(str, 8, 72)
        }

        if ("planned_volume" in track && track.planned_volume.circle_id == circle_id) {
            ctx.font = 'bold 64px sans-serif'
            const str = "v" + track.planned_volume.value
            ctx.fillStyle = "green"
            ctx.strokeStyle = settings.background_color
            ctx.lineWidth = 5
            ctx.strokeText(str, 8, 72)
            ctx.fillText(str, 8, 72)
        }
    }
}

function resize() {
    reset_tracks()
    canvas.portrate = window.innerWidth < window.innerHeight - settings.footer_height - settings.header_height
    document.body.className = canvas.portrate ? "portrate" : "landscape"
    canvas.size = Math.min(window.innerWidth, window.innerHeight)
    if (canvas.portrate) {
        canvas.height = window.innerHeight - settings.footer_height - settings.header_height
        canvas.width = window.innerWidth
        canvas.size = Math.floor(Math.min(canvas.width, canvas.height / (1 + settings.thumbnail.height + settings.instrument.height)))
    } else {
        canvas.height = window.innerHeight
        canvas.width = window.innerWidth - settings.landscape.header_width - settings.landscape.footer_width
        canvas.size = Math.floor(Math.min(canvas.width / (1 + settings.landscape.thumbnail.width + settings.landscape.instrument.width), canvas.height))
    }
    console.log(`orient=${canvas.portrate?'portrate':'landscape'} window=${window.innerWidth}x${window.innerHeight} canvas=${canvas.width}x${canvas.height} size=${canvas.size}` )
}

function on_editor_change(editor) {
    const text = editor.getValue()
    catalog.rhythm.parse(text)
    localStorage.setItem("catalog", catalog.store())
}


class Track {
    constructor(start_x, start_y, ts) {
        this.points = [{ x: start_x, y: start_y, ts: ts }]
    }
    get start() {
        return this.points[0]
    }
    get end() {
        return this.points[this.points.length - 1]
    }
    add_point(x, y, ts) {
        this.points.push({ x: x, y: y, ts: ts })
        if (!("drag" in this)) {
            if (Math.abs(y - this.start.y) > 20) {
                this.drag = "y"
            } else if (Math.abs(x - this.start.x) > 20) {
                this.drag = "x"
            }
        }
    }
}

var tracks

function on_mousedown(e) {
    e.preventDefault()
    if (editor.hasFocus()) {
        editor.getInputField().blur()
        reset_tracks()
        return
    }
    start_track("m", e.clientX, e.clientY, e.timeStamp)
}

function diff_period(x1, x2, period) {
    const d = (x2 - x1) % period
    if (d < -0.5 * period) {
        return d + period
    } else if (d > 0.5 * period) {
        return d - period
    } else {
        return d
    }
}

function on_mousemove(e) {
    e.preventDefault()
    update_track("m", e.clientX, e.clientY, e.timeStamp)
}

function on_mouseup(e) {
    e.preventDefault()
    end_tracks()
}


function start_track(id, x, y, ts) {
    tracks[id] = new Track(x - canvas.getBoundingClientRect().left, y - canvas.getBoundingClientRect().top, ts)
}

function update_track(id, x, y, ts) {
    if (id in tracks) {
        tracks[id].add_point(x, y, ts)
    }

    let touch_ids = Object.keys(tracks)
    if (touch_ids.length == 1) {
        let track = tracks[touch_ids[0]]
        const x = track.start.x - canvas.width / 2
        const y = track.start.y - canvas.height / 2
        const r = Math.sqrt(x * x + y * y)

        const circle = catalog.rhythm.circles[processed.circle_id]
        const radius0 = canvas.size * settings.main.radius0
        
        if (r < radius0) {
            if ("drag" in track) {
                if(track.drag == "y") {
                    track.planned_freq = { circle_id: processed.circle_id, value: clamp((app.freq - (track.end.y - track.start.y) * canvas.size * 0.00002).toFixed(1), 1, 20) }
                }
            }
        } else if (r < canvas.size * settings.main.size) {
            const radius_delta = (canvas.size * 0.5 - radius0) / Math.max(settings.min_radius_devider, circle.radii_count)
            for (const dot of circle.dots) {
                if (in_limits((r - radius0) / radius_delta - dot.radius_id, 0, 1.0)) {
                    if (track.drag == "y") {
                        const ring = circle.rings[dot.ring_id]
                        track.planned_volume = { circle_id: processed.circle_id, ring_id: dot.ring_id, value: clamp((ring.volume.value - (track.end.y - track.start.y) * canvas.size * 0.00002).toFixed(1), 0.0, 2.0) }
                    }
                    break
                }
            }
        }
    }
}

function reset_tracks() {
    tracks = {}
}

function end_tracks() {
    let touch_ids = Object.keys(tracks)
    if (touch_ids.length == 1) {

        const track = tracks[touch_ids[0]]
        const circles = catalog.rhythm.circles
        for (let circle_id = 0; circle_id < circles.length; circle_id++) {
            if (circle_id == processed.circle_id) {

                const x = track.start.x - canvas.width / 2
                const y = track.start.y - canvas.height / 2
                const r = Math.sqrt(x * x + y * y)

                const circle = circles[circle_id]
                const radius0 = canvas.size * settings.main.radius0

                if (r < radius0) {
                    if ("drag" in track) {
                        if(track.drag == "y" && "planned_freq" in track && track.planned_freq.circle_id == circle_id) {
                            app.update_freq(track.planned_freq.value)
                        }
                    } else {
                        toggle_play()
                    }
                } else if (r < canvas.size * settings.main.size) {
                    const radius_delta = (canvas.size * 0.5 - radius0) / Math.max(settings.min_radius_devider, circle.radii_count)
                    const p = (Math.atan2(y, x) / (2 * Math.PI) + 0.25) * circle.period
                    for (const dot of circle.dots) {
                        if (in_limits((r - radius0) / radius_delta - dot.radius_id, 0, 1.0) &&
                            in_limits(diff_period(dot.pulse, p, circle.period), -0.5, 0.5)) {

                            const ring = circle.rings[dot.ring_id]
                            if ("drag" in track) {
                                if (track.drag == "y" && "planned_volume" in track && track.planned_volume.circle_id == circle_id && track.planned_volume.ring_id == dot.ring_id) {
                                    ring.update_volume(track.planned_volume.value)
                                }
                            } else {
                                dot.orig.update_symbol(ring.instrument.next_symbol(dot.symbol))
                            }
                            break
                        }
                    }
                }
            } else {
                let thumbnail_delta, thumbnail_dims
                if (canvas.portrate) {
                    let delta = settings.thumbnail.width
                    if (circles.length > 1) {
                        delta = Math.min(delta, (canvas.width / canvas.size - settings.thumbnail.width) / (circles.length - 1))
                    }
                    thumbnail_delta = [delta, 0]
                    thumbnail_dims = settings.thumbnail
                } else {
                    let delta = settings.landscape.thumbnail.height
                    if (circles.length > 1) {
                        delta = Math.min(delta, (canvas.height / canvas.size - settings.landscape.thumbnail.height) / (circles.length - 1))
                    }
                    thumbnail_delta = [0, delta]
                    thumbnail_dims = settings.landscape.thumbnail
                }

                const x = track.start.x - canvas.size * (thumbnail_dims.width * 0.5 + circle_id * thumbnail_delta[0])
                const y = track.start.y - canvas.size * (thumbnail_dims.height * 0.5 + circle_id * thumbnail_delta[1])
                const r = Math.sqrt(x * x + y * y)

                if (r < canvas.size * thumbnail_dims.size * 0.5) {
                    if (!("drag" in track)) {
                        checkpoint.ts = checkpoint.ts ? processed.ts + settings.start_shift : 0
                        checkpoint.circle_id = circle_id
                        checkpoint.pulse = 0
                        circles.forEach(c => c.reset_played())
                        console.log(`jump to circle=${circle_id} ts=${processed.ts.toFixed(2)}`)
                    }
                }
            }
        }
    }
    reset_tracks()
}

function on_touchstart(e) {
    e.preventDefault()
    if (editor.hasFocus()) {
        editor.getInputField().blur()
        reset_tracks()
        return
    }
    for (let t of e.changedTouches) {
        start_track(t.identifier, t.clientX, t.clientY, e.timeStamp)
    }
    if (Object.keys(tracks).length > 1) {
        reset_tracks()
    }
}

function on_touchmove(e) {
    e.preventDefault()
    for (let t of e.changedTouches) {
        update_track(t.identifier, t.clientX - canvas.getBoundingClientRect().left, t.clientY - canvas.getBoundingClientRect().top, e.timeStamp)
    }
}

function on_touchend(e) {
    e.preventDefault()
    end_tracks()
}

function on_touchcancel(e) {
    if(e.cancelable) {
        e.preventDefault()
    }
    reset_tracks()
}

function on_editor_focus() {
    stop()
    resize()
}

function on_editor_blur() {
    resize()
}

function on_hash_change() {
    const res = location.hash.match("#([^/]+)(?:/(.*))?")
    console.log("hash_changed", res)
    let need_updated = false
    let page = "play"

    if (!res) {
        need_updated = true
        location.hash = "#" + page
    } else {
        if (!["play", "code", "settings", "catalog", "clone"].includes(res[1])) {
            need_updated = true
        } else {
            page = res[1]
            if (res[2]) {
                const rhythm = decodeURIComponent(res[2])
                if (catalog.switch_to(rhythm)) {
                    need_updated = true
                }
                location.hash = "#" + page
            } else if (["play", "code", "clone"].includes(page)) {
                need_updated = true
            }
        }
    }

    if (page == "code") {
        setTimeout(() => { editor.refresh(); editor.focus() }, 0)
    }
    if (need_updated) {
        history.replaceState(null, "", "#" + page + "/" + encodeURIComponent(catalog.rhythm.name))
    }
}

function update_css() {
    document.body.style.setProperty("--header-height", settings.header_height + "px")
    document.body.style.setProperty("--footer-height", settings.footer_height + "px")
    document.body.style.setProperty("--header-width", settings.landscape.header_width + "px")
    document.body.style.setProperty("--footer-width", settings.landscape.footer_width + "px")
}

window.requestAnimationFrame(process)
window.addEventListener('resize', resize, false)
window.addEventListener('hashchange', on_hash_change)
canvas.addEventListener("mousedown",   on_mousedown)
canvas.addEventListener("mousemove",   on_mousemove)
canvas.addEventListener("mouseup",     on_mouseup)
canvas.addEventListener("touchstart",  on_touchstart)
canvas.addEventListener("touchmove",   on_touchmove)
canvas.addEventListener("touchend",    on_touchend)
canvas.addEventListener("touchcancel", on_touchcancel)
document.addEventListener('DOMContentLoaded', resize)
editor.on("focus", on_editor_focus)
editor.on("blur", on_editor_blur)
editor.on("changes", on_editor_change)

var checkpoint = { circle_id: 0, ts: 0, pulse: 0 }
var processed = checkpoint

on_hash_change()
update_css()

</script>
</body>
</html>
